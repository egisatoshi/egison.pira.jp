<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Programming Language Egison Users Manual</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
</head>

<body>
<h1>How to Define Types</h1>
<hr/>
<p>
  We need to define how to do pattern matching for data of each type, to evaluate pattern matching expressions explained in the previous section.<br/>
  In this section, I explain how to define types, and how pattern matching is executed.<br/>
</p>
<hr/>

<h2>Definitions for Collection Data Types</h2>

In this section, I explain the type definitions of lists, multisets, and sets.

<pre>
<code>
(define $List
 (lambda [$a]
  (type
   {[,$val []
     {[$tgt (match [val tgt] [(List a) (List a)]
              {[[&lt;nil&gt; &lt;nil&gt;] {[]}]
               [[&lt;cons $x $xs&gt; &lt;cons ,x ,xs&gt;] {[]}]
               [[_ _] {}]})]}]
    [&lt;nil&gt; []
     {[{} {[]}]
      [_ {}]}]
    [&lt;cons _ _&gt; [a (List a)]
     {[{$x .$xs} {[x xs]}]
      [_ {}]}]
    [&lt;snoc _ _&gt; [a (List a)]
     {[{.$xs $x} {[x xs]}]
      [_ {}]}]
    [&lt;join ,$pxs _&gt; [(List a)]
     {[$tgt
       (letrec
        {[$helper
          (lambda [$pxs $tgt]
           (match [pxs tgt] [(List a) (List a)]
            {[[&lt;nil&gt; _] {tgt}]
             [[&lt;cons $x $xs&gt; &lt;cons ,x $ys&gt;]
               (helper xs ys)]
             [[_ _] {}]}))]}
        (helper pxs tgt))]}]
    [&lt;join _ _&gt; [(List a) (List a)]
     {[$tgt
       (letrec
        {[$helper
          (lambda [$xs $ys]
           (match ys (List a)
            {[&lt;nil&gt; {[xs {}]}]
             [&lt;cons $z $zs&gt;
              {[xs ys] @(helper {@xs z} zs)}]}))]}
        (helper {} tgt))]}]
    [&lt;nioj ,$pxs _&gt; [(List a)]
     {[$tgt (match-all tgt (List a)
             [&lt;join $ys ,pxs&gt; ys])]}]
    [&lt;nioj _ _&gt; [(List a) (List a)]
     {[$tgt
       (letrec
        {[$helper
          (lambda [$xs $ys]
           (match ys (List a)
            {[&lt;nil&gt; {[{} xs]}]
             [&lt;cons $z $zs&gt;
              {[ys xs] @(helper {@xs z} zs)}]}))]}
        (helper {} tgt))]}]
    [_ [Something]
     {[$tgt {tgt}]}]
    })))
</code>
</pre>

<p>
  <code>List</code> is defined as a function that get a type and returns a type for lists of that type.<br/>
  For example, <code>(List Integer)</code> means a list of integer, and <code>(List (List Integer))</code> means a list of lists of integers.<br/>
</p>

<p>
  A <code>type</code> expression is used to define a type.<br/>
  The pattern matching process of Egison is recursively defined.<br/>
  The input of the pattern matching process are a pattern, a target, and a type, and the pattern matching process decompose the input pattern and the input target as the programmer defined in type definition.<br/>
  The decomposed patterns and target data are passed to next pattern matching process with the types that is specified in the type definition too.<br/>
</p>

<p>
  <code>Something</code> is the only built-in type in Egison.<br/>
  Pattern matching process terminates when its input type come to <code>Something</code>.<br/>
  <code>Something</code> can get only a pattern variable for its pattern,
  and bind the target data withount any transformations to the pattern variable.</code>
</p>

<p>
  A <code>type</code> expression is constituted of a collection of <i>type clauses</i>, a tuple of a <i>primitive-pattern-pattern</i>, a <i>next-type-expression</i> and a collection of <i>primitive-match-clauses</i>.<br/>
</p>

<p>
  A <i>primitive-pattern-pattern</i> is a pattern for patterns.<br/>
  The pattern is pattern matched with the primitive-pattern-patterns from the head of the type clauses.<br/>
  If one of the primitive-pattern-pattern is matched with the pattern, 
  the <i>primitive-match-clauses</i> of that type clause are used to get the targets and the types for next pattern matching.<br/>
</p>

<pre>
<code>
&lt;primitive-pp&gt; ::= `&lt;' cons-name &lt;primitive-pp&gt;* `&gt;'
                 | `,$' var-name (value-pat pattern)
                 | `_'           (wild card)
</code>
</pre>

<p>
  Here is syntax of <i>primitive-pattern-patterns</i>.<br/>
  A primitive-pattern-pattern is an inductive data whose element is a wildcard or a value-pattern pattern.<br/>
  A primitive-pattern-pattern which is enclosed with `<code>&lt;</code>' and `<code>&gt;</code>' matches with the inductive pattern whose constructor name is same.<br/>
</p>

<p>
  An value-pattern-pattern is matched with the value pattern and bind its value to <code>var-name</code>.<br/>
  These bindings are used in the evaluation of the primitive-match-clause.<br/>
</p>

<p>
  `<code>_</code>' is matched with any pattern, and the pattern which is matched with the wildcard is passed as the pattern for next pattern matching.<br/>
</p>

<p>
  A primitive-match-clause is constituted of <i>primitive-data-pattern</i> and a body expression which is evaluated to next pattern matching targets.<br/>
  The way of Pattern matching of primitive-data-pattern is same with the ordinary pattern matching.<br/>
  It has only one result, and not allow repeated pattern variables.<br/>
  Here is syntax of primitive data patterns.<br/>
</p>

<pre>
<code>
&lt;primitive-dp&gt; ::= `_'
                 | `$' var-name
                 | `&lt;' cons-name &lt;primitive-dp&gt;* `&gt;'
                 | `{}'
                 | `{' &lt;primitive-dp&gt; .&lt;primitive-dp&gt;  `}'
                 | `{' .&lt;primitive-dp&gt; &lt;primitive-dp&gt;  `}'
</code>
</pre>

<p>
  '<code>_</code>' is a <i>primitive wild card</i>.<br/>
  It matches with any values.<br/>
</p>

<p>
  A pattern variable which appears in the primitive pattern is a <i>primitive pattern variable</i>.<br/>
  It matches with any value, and the value is bound to it.<br/>
</p>

<p>
  <code>&lt;cons-name &lt;primitive-dp&gt;*&gt;</code> is a <i>primitive inductive pattern</i>.<br/>
  This pattern matches when the target value is an inductive value whose constructor is the same with <code>cons-name</code>.<br/>
  Pattern matchings for each argument are recursively executed.<br/>
</p>

<p>
  <code>{}</code> is a <i>primitive empty pattern</i>.<br/>
  This pattern matches when the target value is an empty collection.<br/>
</p>

<p>
  <code>{&lt;primitive-dp&gt; .&lt;primitive-dp&gt;}</code> is a <i>primitive cons pattern</i>.<br/>
  This pattern matches when the target collection contain more than one element.<br/>
  The first <code>primitive-dp</code> is matched with the first element of the target collection, and the second <code>primitive-dp</code> is matched with the rest elements of the target collection.<br/>
</p>

<p>
  <code>{.&lt;primitive-dp&gt; &lt;primitive-dp&gt;}</code> is a <i>primitive snoc pattern</i>.<br/>
  This pattern matches when the target collection contain more than one element.<br/>
  The second <code>{primitive-dp} is matched with the last element of the target collection, and the first <code>primitive-dp</code> is matched with the rest elements of the target collection.<br/>
</p>

<p>
  These three primitive patterns are the primitive operation for collections.<br/>
  All operations for collections derive from these.<br/>
  Collections are matched as a list in primitive pattern matching.<br/>
</p>

<p>
  Now, I've explained all components of type expressions.<br/>
  Then, we walk through how patterm matching proceed with an example.<br/>
  Let's consider the case that the type is <code>(List Integer)</code>,
  the pattern is <code>&lt;join $xs &lt;cons _ $ys&gt;&gt;</coee>,
and the target is <code>{1 2 3}</code>.<br/>
</p>

<p>
  The both argument pattern constructor <code>join</code> is not a value pattern.<br/>
  So, the primitive-pattern-pattern of sixth type clause <code>&lt;join _ _&gt;</code> is matched with the input pattern.<br/>
  First `<code>_</code>' of the primitive-pattern-pattern is matched with <code>$xs</code>,
  and second `<code>_</code>' of the primitive-pattern-pattern is matched with <code>&lt;cons _ $ys&gt;</code>.<br/>
  Therefore <code>$xs</code> and <code>&lt;cons _ $xs&gt;</code> are passed to next pattern matching process as next patterns.<br/>
</p>

<p>
  The next-type-expression of matched type-clause is <code>[(List a) (List a)]</code>,
  and <code>a</code> is bound to <code>Integer</code>.<br/>
  Therefore  <code>(List Integer)</code> and <code>(List Integer)</code> are passed to next pattern matching process as next types.<br/>
</p>

<p>
  The primitive-match-cluases return a collection of next types.<br/>
  The primitive-match-cluases of this type-caluse has only one prmitive-match-cluase.<br/>
  The primitive-data-pattern of this primitive-match-clause is <code>$tgt</code>,
  and it is matched with and bound to the target data <code>{1 2 3}</code>.<br/>
  The body of primitive-match-clause is evaluated and it returns
  <code>{[{} {1 2 3}] [{1} {2 3}] [{1 2} {3}] [{1 2 3} {}]}</code>.<br/>
  All elements of this collection are passed to next pattern mathing as next targets.<br/>
  There are multiple ways to destruct the collection with <code>join</code> pattern constructor.<br/>
  Pattern matching process are recursively executed for all these destruction.<br/>
</p>

<p>
  Next types, next patterns, and next targets have same number of elements.<br/>
  That is, the first next targets are <code>[{} {1 2 3}]</code>, so the <code>{}</code> is matched with the pattern <code>$xs</code> as <code>(List Integer)</code>,
  and the <code>{1 2 3}</code> is matched with the pattern <code>&lt;cons _ $xs&gt;</code> as <code>(List Integer)</code>, in next pattern matching.<br/>
</p>

<p>
...
</p>

<p>
  The difference between the <code>join</code> and <code>nioj</code> pattern constructor is the order of evaluation of pattern matching process.
</p>

<pre>
<code>
(define $Multiset
 (lambda [$a]
  (type
   {[,$val []
     {[$tgt (match [val tgt] [(List a) (Multiset a)]
              {[[&lt;nil&gt; &lt;nil&gt;] {[]}]
               [[&lt;cons $x $xs&gt; &lt;cons ,x ,xs&gt;] {[]}]
               [[_ _] {}]})]}]
    [&lt;nil&gt; []
     {[{} {[]}]
      [_ {}]}]
    [&lt;cons ,$px _&gt; [(Multiset a)]
     {[$tgt (if ((member? a) px tgt)
                {((remove a) tgt px)}
                {})]}]
    [&lt;cons _ _&gt; [a (Multiset a)]
     {[$tgt
       (letrec
        {[$helper
          (lambda [$xs $ys]
           (match ys (List a)
            {[&lt;nil&gt; {}]
             [&lt;cons $z $zs&gt;
              (if ((member? a) z xs)
                  (helper {@xs z} zs)
                  {[z {@xs @zs}]
                   @(helper {@xs z} zs)})]}))]}
        (helper {} tgt))]}]
    [&lt;join ,$pxs _&gt; [(Multiset a)]
     {[$tgt
       (letrec
        {[$helper
          (lambda [$xs $ys]
           (match xs (List Something)
             {[&lt;nil&gt; ys]
              [&lt;cons $z $zs&gt;
               (if ((member? a) z ys)
                   (helper zs ((remove a) ys z))
                   {})]}))]}
        {(helper pxs tgt)})]}]
    [&lt;join _ _&gt; [(Multiset a) (Multiset a)]
     {[$tgt
       (foldr
        (lambda [$xi $xs]
         (let {[[$x $i] xi]}
          (map&concat
           (lambda [$sub] 
            (do {[[$ys $zs] sub]
                 [$zs ((remove-all a) zs x)]}
             (match-all (loop $l $j (between 1 i)
                              {x @l} {})
                        (List a)
              [&lt;join $us $vs&gt; [{@us @ys} {@zs @vs}]])))
        xs)))
        {[{} tgt]}
        ((occurrence a) tgt))]}]
    [_ [Something]
     {[$tgt {tgt}]}]
    })))
</code>
</pre>

</body>

<footer>
  <hr size=1 noshade>
  <table width=100% border=0 cellspacing=0>
    <tr>
      <td align=right>
        <i>
          <a href="http://egi.pira.jp">Egi Satoshi</a>
        </i>
    </tr>
  </table>
</footer>

</html>
