<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Programming Language Egison Users Manual</title>
<meta http-equiv="Content-Matcher" content="text/html;charset=UTF-8" />
</head>

<body>
<h1>How to Define Matchers</h1>
<hr/>
<p>
  We need to define how to do pattern matching for data of each matcher, to evaluate pattern matching expressions explained in the previous section.<br/>
  In this section, I explain how to define matchers, and how pattern matching is executed.<br/>
</p>
<hr/>

<h2>Definitions for Collection Data Matchers</h2>

In this section, I explain the matcher definitions of lists, multisets, and sets.

<pre>
<code>
(define $list
  (lambda [$a]
    (matcher
      {[,$val []
        {[$tgt (match [val tgt] [(list a) (list a)]
                 {[[<nil> <nil>] {[]}]
                  [[<cons $x $xs> <cons ,x ,xs>] {[]}]
                  [[_ _] {}]})]}]
       [<nil> []
        {[{} {[]}]
         [_ {}]}]
       [<cons $ $> [a (list a)]
        {[{$x @$xs} {[x xs]}]
         [_ {}]}]
       [<snoc $ $> [a (list a)]
        {[{@$xs $x} {[x xs]}]
         [_ {}]}]
       [<join ,$pxs $> [(list a)]
        {[$tgt (letrec {[$helper (lambda [$pxs $tgt]
                                   (match [pxs tgt] [(list a) (list a)]
                                     {[[<nil> _] {tgt}]
                                      [[<cons $x $xs> <cons ,x $ys>] (helper xs ys)]
                                      [[_ _] {}]}))]}
                 (helper pxs tgt))]}]
       [<join $ $> [(list a) (list a)]
        {[$tgt (letrec {[$helper (lambda [$xs $ys]
                                   (match ys (list a)
                                     {[<nil> {[xs {}]}]
                                      [<cons $z $zs> {[xs ys] @(helper {@xs z} zs)}]}))]}
                 (helper {} tgt))]}]
       [<nioj ,$pxs $> [(list a)]
        {[$tgt (match-all tgt (list a) [<join $ys ,pxs> ys])]}]
       [<nioj $ $> [(list a) (list a)]
        {[$tgt (letrec {[$helper (lambda [$xs $ys]
                                   (match ys (list a)
                                     {[<nil> {[{} xs]}]
                                      [<cons $z $zs> {[ys xs] @(helper {@xs z} zs)}]}))]}
                 (helper {} tgt))]}]
       [$ [something]
        {[$tgt {tgt}]}]
       })))
</code>
</pre>

<p>
  <code>list</code> is defined as a function that get a matcher and returns a matcher for lists of that matcher.<br/>
  For example, <code>(list integer)</code> means a list of integer, and <code>(list (list integer))</code> means a list of lists of integers.<br/>
</p>

<p>
  A <code>matcher</code> expression is used to define a matcher.<br/>
  The pattern matching process of Egison is recursively defined.<br/>
  The input of the pattern matching process are a pattern, a target, and a matcher, and the pattern matching process decompose the input pattern and the input target as the programmer defined in matcher definition.<br/>
  The decomposed patterns and target data are passed to next pattern matching process with the matchers that is specified in the matcher definition too.<br/>
</p>

<p>
  <code>something</code> is the only built-in matcher in Egison.<br/>
  Pattern matching process terminates when its input matcher come to <code>something</code>.<br/>
  <code>something</code> can get only a pattern variable for its pattern,
  and bind the target data withount any transformations to the pattern variable.</code>
</p>

<p>
  A <code>matcher</code> expression is constituted of a collection of <i>matcher clauses</i>, a tuple of a <i>primitive-pattern-pattern</i>, a <i>next-matcher-expression</i> and a collection of <i>primitive-match-clauses</i>.<br/>
</p>

<p>
  A <i>primitive-pattern-pattern</i> is a pattern for patterns.<br/>
  The pattern is pattern matched with the primitive-pattern-patterns from the head of the matcher clauses.<br/>
  If one of the primitive-pattern-pattern is matched with the pattern, 
  the <i>primitive-match-clauses</i> of that matcher clause are used to get the targets and the matchers for next pattern matching.<br/>
</p>

<pre>
<code>
&lt;primitive-pp&gt; ::= `&lt;' cons-name &lt;primitive-pp&gt;* `&gt;'
                 | `,$' var-name (value-pat pattern)
                 | `_'           (wild card)
</code>
</pre>

<p>
  Here is syntax of <i>primitive-pattern-patterns</i>.<br/>
  A primitive-pattern-pattern is an inductive data whose element is a wildcard or a value-pattern pattern.<br/>
  A primitive-pattern-pattern which is enclosed with `<code>&lt;</code>' and `<code>&gt;</code>' matches with the inductive pattern whose constructor name is same.<br/>
</p>

<p>
  An value-pattern-pattern is matched with the value pattern and bind its value to <code>var-name</code>.<br/>
  These bindings are used in the evaluation of the primitive-match-clause.<br/>
</p>

<p>
  `<code>_</code>' is matched with any pattern, and the pattern which is matched with the wildcard is passed as the pattern for next pattern matching.<br/>
</p>

<p>
  A primitive-match-clause is constituted of <i>primitive-data-pattern</i> and a body expression which is evaluated to next pattern matching targets.<br/>
  The way of Pattern matching of primitive-data-pattern is same with the ordinary pattern matching.<br/>
  It has only one result, and not allow repeated pattern variables.<br/>
  Here is syntax of primitive data patterns.<br/>
</p>

<pre>
<code>
&lt;primitive-dp&gt; ::= `_'
                 | `$' var-name
                 | `&lt;' cons-name &lt;primitive-dp&gt;* `&gt;'
                 | `{}'
                 | `{' &lt;primitive-dp&gt; .&lt;primitive-dp&gt;  `}'
                 | `{' .&lt;primitive-dp&gt; &lt;primitive-dp&gt;  `}'
</code>
</pre>

<p>
  '<code>_</code>' is a <i>primitive wild card</i>.<br/>
  It matches with any values.<br/>
</p>

<p>
  A pattern variable which appears in the primitive pattern is a <i>primitive pattern variable</i>.<br/>
  It matches with any value, and the value is bound to it.<br/>
</p>

<p>
  <code>&lt;cons-name &lt;primitive-dp&gt;*&gt;</code> is a <i>primitive inductive pattern</i>.<br/>
  This pattern matches when the target value is an inductive value whose constructor is the same with <code>cons-name</code>.<br/>
  Pattern matchings for each argument are recursively executed.<br/>
</p>

<p>
  <code>{}</code> is a <i>primitive empty pattern</i>.<br/>
  This pattern matches when the target value is an empty collection.<br/>
</p>

<p>
  <code>{&lt;primitive-dp&gt; .&lt;primitive-dp&gt;}</code> is a <i>primitive cons pattern</i>.<br/>
  This pattern matches when the target collection contain more than one element.<br/>
  The first <code>primitive-dp</code> is matched with the first element of the target collection, and the second <code>primitive-dp</code> is matched with the rest elements of the target collection.<br/>
</p>

<p>
  <code>{.&lt;primitive-dp&gt; &lt;primitive-dp&gt;}</code> is a <i>primitive snoc pattern</i>.<br/>
  This pattern matches when the target collection contain more than one element.<br/>
  The second <code>{primitive-dp} is matched with the last element of the target collection, and the first <code>primitive-dp</code> is matched with the rest elements of the target collection.<br/>
</p>

<p>
  These three primitive patterns are the primitive operation for collections.<br/>
  All operations for collections derive from these.<br/>
  Collections are matched as a list in primitive pattern matching.<br/>
</p>

<p>
  Now, I've explained all components of matcher expressions.<br/>
  Then, we walk through how patterm matching proceed with an example.<br/>
  Let's consider the case that the matcher is <code>(list integer)</code>,
  the pattern is <code>&lt;join $xs &lt;cons _ $ys&gt;&gt;</coee>,
and the target is <code>{1 2 3}</code>.<br/>
</p>

<p>
  The both argument pattern constructor <code>join</code> is not a value pattern.<br/>
  So, the primitive-pattern-pattern of sixth matcher clause <code>&lt;join _ _&gt;</code> is matched with the input pattern.<br/>
  First `<code>_</code>' of the primitive-pattern-pattern is matched with <code>$xs</code>,
  and second `<code>_</code>' of the primitive-pattern-pattern is matched with <code>&lt;cons _ $ys&gt;</code>.<br/>
  Therefore <code>$xs</code> and <code>&lt;cons _ $xs&gt;</code> are passed to next pattern matching process as next patterns.<br/>
</p>

<p>
  The next-matcher-expression of matched matcher-clause is <code>[(list a) (list a)]</code>,
  and <code>a</code> is bound to <code>integer</code>.<br/>
  Therefore  <code>(list integer)</code> and <code>(list integer)</code> are passed to next pattern matching process as next matchers.<br/>
</p>

<p>
  The primitive-match-cluases return a collection of next matchers.<br/>
  The primitive-match-cluases of this matcher-caluse has only one prmitive-match-cluase.<br/>
  The primitive-data-pattern of this primitive-match-clause is <code>$tgt</code>,
  and it is matched with and bound to the target data <code>{1 2 3}</code>.<br/>
  The body of primitive-match-clause is evaluated and it returns
  <code>{[{} {1 2 3}] [{1} {2 3}] [{1 2} {3}] [{1 2 3} {}]}</code>.<br/>
  All elements of this collection are passed to next pattern mathing as next targets.<br/>
  There are multiple ways to destruct the collection with <code>join</code> pattern constructor.<br/>
  Pattern matching process are recursively executed for all these destruction.<br/>
</p>

<p>
  Next matchers, next patterns, and next targets have same number of elements.<br/>
  That is, the first next targets are <code>[{} {1 2 3}]</code>, so the <code>{}</code> is matched with the pattern <code>$xs</code> as <code>(list integer)</code>,
  and the <code>{1 2 3}</code> is matched with the pattern <code>&lt;cons _ $xs&gt;</code> as <code>(list integer)</code>, in next pattern matching.<br/>
</p>

<p>
...
</p>

<p>
  The difference between the <code>join</code> and <code>nioj</code> pattern constructor is the order of evaluation of pattern matching process.
</p>

<pre>
<code>
(define $multiset
  (lambda [$a]
    (matcher
      {[,$val []
        {[$tgt (match [val tgt] [(list a) (multiset a)]
                 {[[<nil> <nil>] {[]}]
                  [[<cons $x $xs> <cons ,x ,xs>] {[]}]
                  [[_ _] {}]})]}]
       [<nil> []
        {[{} {[]}]
         [_ {}]}]
       [<cons ,$px $> [(multiset a)]
        {[$tgt (if (member? px tgt)
                   {(remove tgt px)}
                   {})]}]
       [<cons $ $> [a (multiset a)]
        {[$tgt (letrec {[$helper (lambda [$xs $ys]
                                   (match ys (list a)
                                     {[<nil> {}]
                                      [<cons $z $zs> (if (member? z xs)
                                                         (helper {@xs z} zs)
                                                         {[z {@xs @zs}] @(helper {@xs z} zs)})]}))]}
                 (helper {} tgt))]}]
       [<join ,$pxs _> [(multiset a)]
        {[$tgt (letrec {[$helper (lambda [$xs $ys]
                                   (match xs (list something)
                                     {[<nil> ys]
                                      [<cons $z $zs> (if (member? z ys)
                                                         (helper zs (remove ys z))
                                                         {})]}))]}
                 {(helper pxs tgt)})]}]
       [<join $ $> [(multiset a) (multiset a)]
        {[$tgt
          (foldr
                 (lambda [$xi $xs]
                   (let {[[$x $i] xi]}
                     (map-and-concat
                                     (lambda [$sub] 
                                       (do {[[$ys $zs] sub]
                                            [$zs ((remove-all a) zs x)]}
                                         (match-all (loop $l $j (between 1 i) {x @l} {}) (list a) [<join $us $vs> [{@us @ys} {@zs @vs}]])))
                                     xs)))
                 {[{} tgt]}
                 ((occurrence a) tgt))]}]
       [_ [something]
        {[$tgt {tgt}]}]
       })))
</code>
</pre>

</body>

<footer>
  <hr size=1 noshade>
  <table width=100% border=0 cellspacing=0>
    <tr>
      <td align=right>
        <i>
          <a href="http://egi.pira.jp">Egi Satoshi</a>
        </i>
    </tr>
  </table>
</footer>

</html>
