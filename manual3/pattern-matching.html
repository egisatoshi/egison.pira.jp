<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Programming Language Egison Users Manual</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9772679-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>

<body>
<h1>Pattern Matching</h1>
<hr/>
<p>
  How do you express a set?
  Probably, most of you represents it as a list.
  But, this representation raises another question.
  Why do you choose the order? Is it meaningful?
  Data such as sets have no normal form, and are called <i>unfree data</i>.
  Unfortunately, it has been difficult to do pattern matching for them.
  Egison gives various pattern matching for those data.
  We demonstrate it here with many examples, which contain pattern matching for lists, multisets, and sets.
</p>

<hr/>

<h2 id="pattern-matching">Let's do Pattern Matching for Collections!!</h2>

<p>
  In this section, we show various basic pattern matching for collections, such as lists, multisets, and sets.
  At first, let's execute the following code.
  We explain its meaning later.
</p>

<pre>
  <code>
&gt; (test (match-all {1 2 3 4} (list integer)
          [&lt;cons $x $xs&gt; [x xs]]))

{[1 {2 3 4}]}


&gt; (test (match-all {1 2 3 4} (multiset integer)
          [&lt;cons $x $xs&gt; [x xs]]))

{[1 {2 3 4}] [2 {1 3 4}] [3 {1 2 4}] [4 {1 2 3}]}


&gt; (test (match-all {1 2 3 4} (set integer)
          [&lt;cons $x $xs&gt; [x xs]]))

{[1 {1 2 3 4}] [2 {1 2 3 4}] [3 {1 2 3 4}] [4 {1 2 3 4}]}
  </code>
</pre>

<p>
  All of them say "take an element from the collection <code>{1 2 3 4}</code>".
  If you regard <code>{1 2 3 4}</code> as a list, you will take the head <code>1</code>.
  However, if you assume the collection is a set, which element you should take
  The set {1 2 3 4} has forms such as {2 1 4 3}, {4 3 2 1}, {1 2 1 3 1 4 1}, and so on.
  If you take the "head" of the set, you will get 1, 2, 3, or 4.
  Egison returns all of them.
  That is, a <code>match-all</code> expression returns the collection of results of an evaluation of the formula with the matched pattern.
  Since an unfree datum has no normal form but many forms as explained above, the collection can have multiple elements.
</p>

<p>
  As explained in the previous chapter, the arguments of a <code>match-all</code> expression are a target, a matcher, a pattern, and a formula.
  The pattern and the formula construct a <i>match-clause</i>, and the formula is called the <i>body</i> of the match-clause.
  That is, a <i>match-clause</i> has the form <code>[<i>pattern</i> <i>body</i>]</code>.
  In the above examples, their match-clauses are all "<code>[&lt;cons $x $xs&gt; [x xs]]</code>", and the body of it is "<code>{[x xs]}</code>".
  A match-clause defines a sequence of actions in the pattern matching.
  In this case, it means "deconstruct an object in the way defined as cons, and then bind adequate objects to <code>x</code> and <code>xs</code>".
  The meaning of <code>cons</code>, i.e., what kind of objects matches and what are bound to <code>x</code> and <code>xs</code> depends on matchers.
  In general, it divides a collection into an element and the rest of the collection.
  If a matcher is <code>list</code>, <code>x</code> is the head of the collection and <code>xs</code> is th rest as ordinary programming languages.
  For example, in the above case, <code>x</code> is 1 and <code>xs</code> is {2 3 4}.
  In the case of <code>multiset</code>, that is, a matcher of a collection whose order is meaningless, any element in the target is bound to <code>x</code>.
  The above example shows the possible pairs <code>[x xs]</code> are <code>[1 {2 3 4}]</code>, <code>[2 {3 4 1}]</code>, <code>[3 {4 1 2}]</code>, and <code>[4 {1 2 3}]</code>.
  Note its order is also meaningless.
  When the numbers of occurences of elements in the collection is also meaningless, that is, it is a set, an element bound to <code>x</code> can be contained in the collection bound to <code>xs</code>.
  You can confirm the fact by the above example.
</p>

<p>
  Of course, there are inductive patterns for collections other than <code>cons</code>.
  Here is another example, <code>join</code>.
</p>

<pre>
  <code>
&gt; (test (match-all {1 2 3} (list integer)
          [&lt;join $xs $ys&gt; [xs ys]]))

{[{} {1 2 3}] [{1} {2 3}] [{1 2} {3}] [{1 2 3} {}]}


&gt; (test (match-all {1 2 3} (multiset integer)
          [&lt;join $xs $ys&gt; [xs ys]]))

{[{} {1 2 3}] [{3} {1 2}] [{2} {1 3}] [{2 3} {1}]
 [{1} {2 3}] [{1 3} {2}] [{1 2} {3}] [{1 2 3} {}]}
  </code>
</pre>

<p>
  <code>join</code> is a pattern that divides a collection into two collections, the two arguments of it.
  Intuitively, <code>join</code> is "<code>cons</code> iteration".
  That is, <code>&lt;join $x $y&gt;</code> is <code>&lt;cons $x1 &lt;cons $x2 &lt;...&lt;cons $xn $y&gt;...&gt;&gt;&gt;</code> and <code>x</code> is equal to <code>{x1 x2 ... xn}</code>.
  Matchers <code>list</code> and <code>multiset</code> are equipped with <code>join</code>.
  The way <code>list</code> divides a collection preserves the order of the collection.
  For example, all matches <code>&lt;join ,{1 2} ,{3}&gt;</code> is <code>{1 2 3}</code>.
  By contrast, <code>multiset</code> breaks the order.
  In the example, the pattern is matched by <code>{1 2 3}</code>, <code>{1 3 2}</code>, <code>{2 1 3}</code>, and so on.
</p>

<p>
  An interesting example using <code>cons</code> and <code>join</code> is nondeterministic pattern matching for a list.
  For example, you want to divide an even-number element by 2.
</p>

<pre>
  <code>
&gt; (test (match-all {1 2 3 4} (list integer) [&lt;join $xs &lt;cons (&amp; $y) $zs&gt;&gt; {@xs y @zs}]))
  </code>
</pre>

<hr/>

<p>
  The list data type has special pattern constructors, <code>snoc</code> and <code>nioj</code>.
</p>

<pre>
  <code>
&gt; (test (match-all {1 2 3} (list integer)
          [&lt;snoc $x $xs&gt; [x xs]]))

{[3 {1 2}]}

      
&gt; (test (match-all {1 2 3} (list integer)
          [&lt;nioj $xs $ys&gt; [xs ys]]))

{[{} {1 2 3}] [{3} {1 2}] [{2 3} {1}] [{1 2 3} {}]}
  </code>
</pre>

<p>
  The arguments of <code>snoc</code> matches with the last element of a target collection and the rest of it.
  Note that, in Egison, extraction of an element from the tail of a collection is represented in the same way with the head of it.
  A pattern constructor <code>nioj</code> is similar to <code>join</code>, and used to divide a target collection into two collections.
  The difference between <code>join</code> and <code>nioj</code> is the order of pattern matching, as its name suggests.
  In case of <code>nioj</code>, pattern matching is executed from the back-side of a collection.
  The order of pattern matching is important when we do pattern matching using non-linear patterns, which we will discuss in the next section.
</p>

<h2 id="non-linear-patterns">Non-linear Patterns</h2>

<p>
  Egison allows programers to "bind and use" variables in a pattern.
  A pattern that contains multiple occurences of a variable is called a <i>non-linear pattern</i>.
  Egison is the first language that non-linear patterns can be used in pattern matching for unfree data.
  The following is an example of non-linear patterns.
</p>

<pre>
  <code>
&gt; (test (match-all {1 2 3 1 2} (multiset integer)
          [&lt;cons $n &lt;cons ,n _&gt;&gt; n]))

{1 2}
  </code>
</pre>

<p>
  The output of this example is a collection of numbers which are contained in the target collection at least twice.
</p>

<p>
  Since pattern matching of Egison is executed from left to right,
  the value bound to a pattern variable can be referred to in its right side of the pattern.
  In this case, when the matching process proceeds to the pattern <code>,n</code>,
  the expression <code>n</code> is evaluated to the value to which <code>$n</code> is bound.
  The pattern <code>,n</code> is matched as an integer, so if the target value is equal to the value bound to <code>$n</code> as an integer,
  the pattern matching succeeds.
  '<code>_</code>' is a <i>wild card</i> which matches with any values.
</p>

<p>
  Here is another example.
</p>

<pre>
  <code>
&gt; (test (match-all {{1 2 3 4 5} {4 5 1} {6 1 7 4}} (list (multiset integer))
          [&lt;cons &lt;cons $n _&gt; &lt;cons &lt;cons ,n _&gt; &lt;cons &lt;cons ,n _&gt; &lt;nil&gt;&gt;&gt;&gt; n]))

{1 4}
  </code>
</pre>

<p>
  With Egison, we are able to do pattern matching with nested data types easily.
  The target value is a collection of collections of integers.
  It is matched as a list of multisets of integers.
  This pattern extracts an element from each collection, which is an element of the target collection.
</p>

<h2 id="cut-patterns">Cut Patterns</h2>

<pre>
  <code>
&gt; (test (match {2 7 7 2 7} (multiset integer)
          {[&lt;cons $m &lt;cons ,m &lt;cons ,m
             &lt;cons $n !&lt;cons ,n !&lt;nil&gt;&gt;&gt;&gt;&gt;&gt;
            &lt;ok&gt;]
           [_ &lt;ko&gt;]}))

&lt;ok&gt;
  </code>
</pre>

<p>
  Egison also has <code>match</code> expressions.
  A <code>match</code> expression takes a collection of match clauses.
  Matching process is executed from the top of the match clauses.
  The body of first succeeded match clause is evalated.
</p>

<p>
  The pattern of the first match clause matches if the target value is collection which contains three same number and other two same number.
  The target matches with the pattern of the first match clause, so the return value is <code><ok></code>.
</p>

<p>
  A pattern which has '<code>!</code>' at the head is called a <i>cut pattern</i>.
  If there are several matchings to the point of the cut pattern, one of them are taken and pattern matching for the rest of the pattern is executed.
  If pattern matching after the position of the cut pattern fails, backtracking before the position of the cut pattern is not executed.
  Cut patterns are used to avoid unnecessary search.
  In the above case, since there is only one combination that three same number appears among the collection which has five elements,
  further search is not required if pattern matching failed after a triple of three same number is found.
  This cut pattern represent this fact.
</p>

<p>
  If pattern matching after the cut pattern succeed, backtracking before the position of the cut pattern is executed as there is no cut pattern.
</p>

<pre>
  <code>
&gt; (test (match-all {1 2 3} (multiset integer)
          [&lt;cons $x &lt;cons $y &lt;cons $z !&lt;nil&gt;&gt;&gt;&gt; [x y z]]))

{[1 2 3] [1 3 2] [2 1 3] [2 3 1] [3 1 2] [3 2 1]}
  </code>
</pre>

<p>
  The cut pattern is especially useful for pattern matching with multisets.
  The power of cut patterns is demonstrated with the code that determines poker hands.
  (<a href="./poker-hands.html">Example1. Poker Hands</a>)
</p>

<h2>Reucrsive Patterns</h2>

<pre>
  <code>
&gt; (test (match-all {1 2 3 4} (list integer)
          [&lt;join _ &lt;cons $m &lt;join _ &lt;cons $n _&gt;&gt;&gt;&gt; [m n]]))

{[1 2] [1 3] [1 4] [2 3] [2 4] [3 4]}
  </code>
</pre>

<p>
  The output of the above expression is all combinations of two elements from the target collection.
  The output consists of <i>nC2</i> elements where <code>n</code> is the length of the target collection.
  The first '<code>_</code>' matches with some front part of the target collection,
  and <code>$m</code> matches with the element behind it.
  The second '<code>_</code>' matches with some subcollection that follows after the element bound to <code>\$m</code>,
  and <code>$n</code> matches with the element behind it.
  The last '<code>_</code>' matches with the rest of collection.
  For example, the case <code>$m</code> bound to <code>1</code> and <code>$n</code> bound to <code>2</code>,
  the first and the second '<code>_</code>' matches with empty collection,
  and the last '<code>_</code>' matches with the collection <code>{3 4}</code>.
</p>

<p>
  The pattern which generates <i>nCk</i> combinations of elements can be written for any fixed <i>k</i> in the same way.
  However, it is not possible to write a pattern for dynamically changing <i>k</i> in the same way.
  This is because we cannot write patterns including a parameter that determines the count of pattern variables in them.
  Egison has the special pattern syntax, <code>loop</code> expressions and <i>subscripted variables</i> to enable it.
</p>

<p>
  A variable whose name contains `_' and an expression which returns integer in its tail is called a subscripted variable.
  It is similar to an array of other programming languages.
  A difference is it can be used in patterns as a pattern variable.
  We can append several subscritions to one variable.
</p>

<p>
  A <code>loop</code> expression takes a <i>recursive variable</i>, an <i>lindex variable</i>, a <i>range expression</i>, a <i>middle expression</i>, and a <i>tail expression</i>.
  A range expression returns a index collection.
  The index variable runs through its elements.
  A <code>loop</code> expression is expanded to the middle expression when it has one and more elements.
  When there are no elements, a <code>loop</code> expression is expanded to the tail expression.
  The loop variable in the middle expression is expanded to the next middle expression when there is the next element in the index collection.
  If there is no unused element in the index collection, the loop variable in the middle expression is expanded to the tail expression.
</p>

<pre>
  <code>
&gt; (define $combination
    (lambda [$xs $k]
      (match-all xs (list something)
        [(loop $l $i (between 1 k) &lt;join _ &lt;cons $a_i l&gt;&gt; _)
         [@(loop $l $i (between 1 k) {a_i @l} {})]])))

&gt; (test (combination {1 2 3 4} 3))

{[1 2 3] [1 2 4] [1 3 4][2 3 4]}
  </code>
</pre>

<p>
  <code>between</code> is a function which take two arguments and return a sequence of numbers between them.
</p>

<pre>
  <code>
&gt; (test (between 2 4))

{2 3 4}
  </code>
</pre>

<p>
  With a loop pattern, we can represent patterns for Hamilton path or cycle of graphs in a single pattern.
  (<a href="./graph.html">Example2. Graphs</a>)
</p>

<hr/>
<p>
  [<a href="../index.html">Egison Top</a>]
  [<a href="./index.html">Egison Manual Top</a>]
</p>

</body>

<footer>
  <table width=100% border=0 cellspacing=0>
    <tr>
      <td align=left>
        <i>
          Copyright (C) 2011-2013 <a href="http://egi.pira.jp/index.html">Satoshi Egi</a>
        </i>
    </tr>
  </table>
</footer>

</html>
