<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Programming Language Egison Users Manual</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9772679-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>

<body>
<h1>Pattern Matching</h1>
<hr/>
<p>
  How do you express a set in a program?
  Probably, most of you represents it as a list.
  However, a list differs from a set in that it has the order.
  Then, even if you want to ignore the order, you have to care about it when we represent a set as a list.
  Data such as sets have no normal form, and are called <i>unfree data</i>.
  Unfortunately, it has been difficult to do pattern matching for them.
  Egison gives strong pattern matching for those data.
  We demonstrate it here with many examples, which contain pattern matching for lists, multisets, and sets.
</p>

<hr/>

<h2 id="pattern-matching">Let's do Pattern Matching for Collections!!</h2>

<p>
  In this section, we show various basic pattern matching for collections, such as lists, multisets, and sets.
  At first, let's execute the following code.
  We explain its meaning later.
</p>

<pre><code>&gt; (test (match-all {1 2 3 4} (list integer)
          [&lt;cons $x $xs&gt; [x xs]]))
{[1 {2 3 4}]}

&gt; (test (match-all {1 2 3 4} (multiset integer)
          [&lt;cons $x $xs&gt; [x xs]]))
{[1 {2 3 4}] [2 {1 3 4}] [3 {1 2 4}] [4 {1 2 3}]}

&gt; (test (match-all {1 2 3 4} (set integer)
          [&lt;cons $x $xs&gt; [x xs]]))
{[1 {1 2 3 4}] [2 {1 2 3 4}] [3 {1 2 3 4}] [4 {1 2 3 4}]}</code></pre>

<p>
  All of them say "take an element from the collection <code>{1 2 3 4}</code>".
  If you regard <code>{1 2 3 4}</code> as a list, you will take the head <code>1</code>.
  However, if you assume the collection is a set, which element you should take
  The set {1 2 3 4} has forms such as {2 1 4 3}, {4 3 2 1}, {1 2 1 3 1 4 1}, and so on.
  If you take the "head" of the set, you will get 1, 2, 3, or 4.
  Egison returns all of them.
  That is, a <code>match-all</code> expression returns the collection of results of an evaluation of the formula with the matched pattern.
  Since an unfree datum has no normal form but many forms as explained above, the collection can have multiple elements.
</p>

<p>
  As explained in the previous chapter, the arguments of a <code>match-all</code> expression are a target, a matcher, a pattern, and a formula.
  The pattern and the formula construct a <i>match-clause</i>, and the formula is called the <i>body</i> of the match-clause.
  That is, a <i>match-clause</i> has the form <code>[<i>pattern</i> <i>body</i>]</code>.
  In the above examples, their match-clauses are all "<code>[&lt;cons $x $xs&gt; [x xs]]</code>", and the body of it is "<code>{[x xs]}</code>".
  A match-clause defines a sequence of actions in the pattern matching.
  In this case, it means "deconstruct an object in the way defined as cons, and then bind <code>x</code> and <code>xs</code> to adequate objects".
  The meaning of <code>cons</code>, i.e., what kind of objects matches and where <code>x</code> and <code>xs</code> are bound depends on matchers.
  In general, it divides a collection into an element and the rest of the collection.
  If a matcher is <code>list</code>, <code>x</code> is the head of the collection and <code>xs</code> is the rest as ordinary programming languages.
  For example, in the above case, <code>x</code> is 1 and <code>xs</code> is {2 3 4}.
  In the case of <code>multiset</code>, that is, a matcher of a collection whose order is meaningless, <code>x</code> is bound to any element in the target.
  The above example shows the possible pairs <code>[x xs]</code> are <code>[1 {2 3 4}]</code>, <code>[2 {3 4 1}]</code>, <code>[3 {4 1 2}]</code>, and <code>[4 {1 2 3}]</code>.
  Note its order is also meaningless.
  When the numbers of occurrences of elements in the collection is also meaningless, that is, it is a set, an element where <code>x</code> are bound can be contained in the collection that <code>xs</code> are bound to.
  You can confirm the fact by the above example.
</p>

<p>
  Of course, there are inductive patterns for collections other than <code>cons</code>.
  Here is another example, <code>join</code>.
</p>

<pre><code>&gt; (test (match-all {1 2 3} (list integer)
          [&lt;join $xs $ys&gt; [xs ys]]))
{[{} {1 2 3}] [{1} {2 3}] [{1 2} {3}] [{1 2 3} {}]}

&gt; (test (match-all {1 2 3} (multiset integer)
          [&lt;join $xs $ys&gt; [xs ys]]))
{[{} {1 2 3}] [{3} {1 2}] [{2} {1 3}] [{2 3} {1}]
 [{1} {2 3}] [{1 3} {2}] [{1 2} {3}] [{1 2 3} {}]}</code></pre>

<p>
<code>join</code> is a pattern that divides a collection into two collections, the two arguments of it.
  Intuitively, <code>join</code> is "<code>cons</code> iteration".
  That is, <code>&lt;join $x $y&gt;</code> is <code>&lt;cons $x1 &lt;cons $x2 &lt;...&lt;cons $xn $y&gt;...&gt;&gt;&gt;</code> and <code>x</code> is equal to <code>{x1 x2 ... xn}</code>.
  Matchers <code>list</code> and <code>multiset</code> are equipped with <code>join</code>.
  The way <code>list</code> divides a collection preserves the order of the collection.
  For example, all matches <code>&lt;join ,{1 2} ,{3}&gt;</code> is <code>{1 2 3}</code>.
  By contrast, <code>multiset</code> breaks the order.
  In the example, the pattern is matched by <code>{1 2 3}</code>, <code>{1 3 2}</code>, <code>{2 1 3}</code>, and so on.
</p>

<p>
  An interesting example using <code>cons</code> and <code>join</code> is non-deterministic pattern matching for a list.
  For example, you want to divide even-number elements by 2 recursively.
  The following function <code>div2</code> gives the list you want to get.
  You may be able to confirm the function works correctly.
  Note that there is no guarantee that <code>div2</code> divides elements from the head.
</p>

<pre><code>&gt; (define $div2
     (lambda [$x]
        (match x (list integer)
           {[&lt;join $xs &lt;cons (&amp; ?(lambda [$x] (eq? (modulo x 2) 0)) $y) $zs&gt;&gt;  (div2 {@xs (quotient y 2) @zs})]
            [_ x]})))
&gt; (test (div2 {1 1 2 3 5 8 13 21 34 55 89 144 233 377 610}))
{1 1 1 3 5 1 13 21 17 55 89 9 233 377 305}</code></pre>

<p>
  The matcher <code>list</code> can deconstruct a collection into the tail and the others.
  The inductive pattern, named <code>snoc</code>, is the "dual" of <code>cons</code>.
  Of course, since a (multi)set has no order, neither <code>multiset</code> nor <code>set</code> has <code>snoc</code>.
  Similarly, <code>list</code> also has the "dual", <code>nioj</code>, of <code>join</code>.
</p>

<pre><code>&gt; (test (match-all {1 2 3} (list integer)
          [&lt;snoc $x $xs&gt; [x xs]]))
{[3 {1 2}]}
      
&gt; (test (match-all {1 2 3} (list integer)
          [&lt;nioj $xs $ys&gt; [xs ys]]))
{[{} {1 2 3}] [{3} {1 2}] [{2 3} {1}] [{1 2 3} {}]}</code></pre>

<p>
  The arguments of <code>snoc</code> matches with the last element of a target collection and the rest of it.
  Note that, in Egison, extraction of an element from the tail of a collection is represented in the same way as the head of it.
  A pattern constructor <code>nioj</code> is similar to <code>join</code>, and used to divide a target collection into two collections.
  The difference between <code>join</code> and <code>nioj</code> is the order of pattern matching, as its name suggests.
  In case of <code>nioj</code>, pattern matching is executed from the back-side of a collection.
  The order of pattern matching is important when we do pattern matching using non-linear patterns, which we will discuss in the next section.
</p>

<h2 id="non-linear-patterns">Non-linear Patterns</h2>

<p>
  Egison allows programmers to "bind and use" variables in a pattern.
  A pattern that contains multiple occurrences of a variable is called a <i>non-linear pattern</i>.
  Egison is the first programming language that non-linear patterns can be used in pattern matching for unfree data.
  The following is an example of non-linear patterns.
</p>

<pre><code>&gt; (test (match-all {1 2 3 1 2} (multiset integer)
          [&lt;cons $n &lt;cons ,n _&gt;&gt; n]))
{1 2 1 2}</code></pre>


<p>
  The output of this example is the collection of numbers duplicated in the target collection.
</p>

<p>
  Since Egison executes pattern matching from left to right,
  a bound pattern variable can be referred to in its right side of the pattern.
  In this example, at first, the variable <code>n</code> is bound to any element of the collection.
  Then, Egison examines the pattern <code>,n</code>.
  It places the right side of <code>$n</code>, it is evaluated to the value where <code>n</code> is bound.
  When an object matches the pattern <code>,n</code>, it is equal to the value as 
<code>integer</code>.
  Therefore, after successful pattern matching, <code>n</code> is bound to an element contained at least two in the target collection.
</p>

<p>
  Here is another example.
  Suppose you have three collections of integers, and need the integers contained in all of the collections.
  You can do the task using the following simple code.
</p>

<pre><code>&gt; (test (match-all {{1 2 3 4 5} {4 5 1} {6 1 7 4}} (list (multiset integer))
          [&lt;cons &lt;cons $n _&gt; &lt;cons &lt;cons ,n _&gt; &lt;cons &lt;cons ,n _&gt; &lt;nil&gt;&gt;&gt;&gt; n]))
{1 4}</code></pre>

<p>
  Probably, you understand how strong the pattern matching of Egison is.
  In this chapter, we show the inductive patterns of the matchers <code>list</code>, <code>multiset</code>, and <code>set</code>.
  If you want to make your own matcher or understand matchers more deeply, you should read the next chapter.
</p>

<h2 id="pattern-constructor">Pattern-Constructor</h2>

<p>
  You may meet the error as follows.
</p>

<pre><code>&gt; (define $p &lt;cons $x $xs&gt;)
&gt; (test (match {1 2 3} (list integer) {[p #t] [_ #f]}))
Error: cannot use variable in pattern</code></pre>

<p>
  Egison prohibits using a variable as a pattern in <i>match-clause</i>.
  To see why, assume that there is no such a restriction.
  Moreover, assume the above <code>p</code> is defined in library.
  Obviously, it is the pattern matched by any non-null collection.
  Using this <code>p</code>, a programmer will write code as follows.
</p>

<pre><code>  (match-all {{1 2 3} {4 5 6}} (list (list integer)) [&lt;cons p &lt;cons &lt;cons $x $xs&gt; &lt;nil&gt;&gt;&gt; [x xs]])
  (match-all {{1 2 3} {4 5 6}} (list (list integer)) [&lt;cons p &lt;cons &lt;cons $y $ys&gt; &lt;nil&gt;&gt;&gt; [y ys]])</pre></code>

<p>
  As you can see, variables <code>x</code> and <code>xs</code> conflict in the upper example.
  Then, although the above two examples have the same form, they may result different values.
  It's too confusing.
  That's why Egison denies a variable bound to a pattern.
</p>

<p>
  However, you probably want to reuse your own pattern.
  Egison prepares pattern-constructors for such a purpose.
</p>

<pre><code>  (pattern-constructor [<i>variable</i> ...] <i>formula</i>)</code></pre>

<p>
  You may notice that it is similar to <code>lambda</code> expression.
  Actually, a pattern-constructor is a function that returns a pattern.
  (Note that you should not create such a function "using <code>lambda</code>".
  Although you can now, that will be prohibited in the future.)
</p>
<p>
  Shown as follows, you can reuse a pattern via a pattern-constructor.
  Since a pattern-constructor has its own namespace, variables don't conflict with variables in a pattern-constructor.
  Then, you don't have to care about which variable occurs in a pattern-constructor.
</p>

<pre><code>&gt; (define $p (pattern-constructor [] &lt;cons $x $xs&gt;))
&gt; (test (match {1 2 3} (list integer) {[(p) #t] [_ #f]}))
#t
&gt; (test (match-all {{1 2 3} {4 5 6}} (list (list integer)) [&lt;cons (p) &lt;cons &lt;cons $x $xs&gt; &lt;nil&gt;&gt;&gt; [x xs]]))
{[4 {5 6}]}
&gt; (test (match-all {{1 2 3} {4 5 6}} (list (list integer)) [&lt;cons (p) &lt;cons &lt;cons $y $ys&gt; &lt;nil&gt;&gt;&gt; [y ys]]))
{[4 {5 6}]}
&gt; (test (match-all {{1 2 3} {4 5 6}} (list (list integer)) [&lt;cons &lt;cons $x $xs&gt; &lt;cons (p) &lt;nil&gt;&gt;&gt; [x xs]]))
{[1 {2 3}]}
&gt; (test (match-all {{1 2 3} {4 5 6}} (list (list integer)) [&lt;cons (p) &lt;cons &lt;cons $y $ys&gt; &lt;nil&gt;&gt;&gt; [x xs]]))
Unbound variable: x</code></pre>

<p>
  The last result means that you can't use almost all variables that occur in a pattern-constructor.
  The exceptions are the arguments of a pattern-constructor.
</p>

<pre><code>&gt; (define $twin (pattern-constructor [$pat1 $pat2] &lt;cons (&amp; $pat pat1) &lt;cons ,pat pat2&gt;&gt;))
&gt; (test (match-all {1 2 1 3} (multiset integer) [&lt;cons _ (twin $n _)&gt; n]))
{1 1 1 1}
&gt; (test (match-all {1 2 1 3} (multiset integer) [&lt;cons _ (twin ,1 _)&gt; #t]))
{#t #t #t #t}
&gt; (test (match-all {2 2 1 3} (multiset integer) [&lt;cons _ (twin ,1 _)&gt; #t]))
{}</code></pre>

<p>
Although Egison restricts use of variables in a match-clause, what you can do isn't limited at all.
On the contrary, you can reuse your own patterns with parameters.
</p>

<h2 id="index-loop">Index-loop</h2>

<p>
  Can you write a function <code>comb2</code> that takes a collection as the argument, and returns the 2-combinations of it?
  This is an easy exercise, and our answer is as follows.
</p>

<pre><code>&gt; (define $comb2
      (lambda [$xs]
        (match-all xs (list something) 
          [&lt;join _ &lt;cons $x1 &lt;join _ &lt;cons $x2 _&gt;&gt;&gt;&gt; [| x1 x2 |]])))
&gt; (test (comb2 {1 2 3 4 5}))
{[|1 2|] [|1 3|] [|2 3|] [|1 4|] [|2 4|] [|3 4|] [|1 5|] [|2 5|] [|3 5|] [|4 5|]}</code></pre>

<p>
  Next, can you write a <code>comb3</code>?
  You will easily rewrite <code>comb2</code> to <code>comb3</code> as follows.
</p>

<pre><code>&gt; (define $comb3
      (lambda [$xs]
        (match-all xs (list something) 
          [&lt;join _ &lt;cons $x1 &lt;join _ &lt;cons $x2 &lt;join _ &lt;cons $x3 _&gt;&gt;&gt;&gt;&gt;&gt; [| x1 x2 x3|]])))
&gt; (test (comb3 {1 2 3 4 5}))
{[|1 2 3|] [|1 2 4|] [|1 3 4|] [|2 3 4|] [|1 2 5|] [|1 3 5|] [|1 4 5|] [|2 3 5|] [|2 4 5|] [|3 4 5|]}</code></pre>

<p>
  If you can, how about <code>comb4</code>, <code>comb5</code>, and so on?
  These <code>combX</code> have the same form, and then it is possible to generalise them.
  You can do such a thing using <code>index-loop</code>.
</p>

<pre><code> (index-loop <i>variable</i> <i>variale</i> <i>variable</i> <i>variable</i> <i>collection</i> <i>formula</i> <i>formula</i>)
</code></pre>

<p>
The first five arguments of index-loop represent the name of the index-loop, an array-variable, an index-variable, and a range of the index.
Since it takes too many arguments, it is difficult to understnd what it does.
Then, at first, we give <code>comb</code> as an example.
</p>

<pre><code>&gt; (define $comb
    (lambda [$xs $n]
      (match-all xs (list something)
        [(index-loop $l $p $i $a (between 1 n)
           &lt;join _ &lt;cons p_i l&gt;&gt;
           _)
         a])))
&gt; (test (comb {1 2 3 4 5} 3))
{[|1 2 3|] [|1 2 4|] [|1 3 4|] [|2 3 4|] [|1 2 5|] [|1 3 5|] [|1 4 5|] [|2 3 5|] [|2 4 5|] [|3 4 5|]}
</code></pre>

<p>
We will describe the outline of behaviour of a index-loop.
It's roughly correct and easier to understand.
Precise definition is given at the end of this section.
</p>

<p>
Egison evaluates and returns the last argument of an index-loop if its fifth argument, a collection, is null.
In the last argument, you can't use the arguments from first to third (in the above example, <code>l</code>, <code>p</code>, and <code>i</code>).
</p>

<p>
Otherwise, Egison evaluates the sixth argument.
Unlike the seventh argument, you can use the arguments from first to third in the sixth arguments.
Egison binds the third variable to the head of the collection, the fifth argument, removes the head from the collection, and then binds the first variable to the index-loop.
That is, the first variable is bound to an index-loop that is the same as the original index-loop except it lacks the head of the collection.
In the above example, 
</p>

<pre><code>  (index-loop $l $p $i $a {1 2 3 4 5}
    &lt;join _ &lt;cons p_i l&gt;&gt;
    _)</code></pre>

<p>
is "the same as"
</p>

<pre><code>  &lt;join _ &lt;cons p_1 (index-loop $l $p $i $a {2 3 4 5}
                      &lt;join _ &lt;cons p_i l&gt;&gt;
                      _)&gt;&gt;</code></pre>

<p>
The second argument is bound to a pattern variable.
As a pattern-constructor, an index-loop has its own namespace, and the second argument belongs to it.
Then, all you can use the second argument in is the sixth argument.
For example, the above example is "the same as"
</p>

<pre><code>  &lt;join _ &lt;cons $m_1 (index-loop $l $p $i $a {2 3 4 5}
                      &lt;join _ &lt;cons p_i l&gt;&gt;
                      _)&gt;&gt;</code></pre>

<p>
Repeating those execution, Egison returns
</p>

<pre><code>  &lt;join _ &lt;cons $m_1 &lt;join _ &lt;cons $m_2 &lt;join _ &lt;cons $m_3 &lt;join _ &lt;cons $m_4 &lt;join _ &lt;cons $m_5 _ &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code></pre>

<p>
In the end of the evaluation, the fourth argument is bound to a value where the second argument is bound.
The fourth argument is accessible from out of the index-loop, although the second can't.
</p>

<p>
Precisely, <code>index-loop</code> is just a syntactic sugar.
Actually, the above <code>comb</code> is desugard to
</p>

<pre><code>(define $comb
  (lambda [$n]
    (pattern-constructor [$a]
      (((letrec {[$helper (lambda [$ns]
                            (pattern-constructor [$q]
                              (match ns (list something)
                                {[&lt;cons $i $ns&gt;
                                  &lt;join _ &lt;cons q_i ((helper ns) q)&gt;&gt;]
                                 [&lt;nil&gt; _]})))]} helper) (between 1 n))
       a))))</code></pre>

<p>
The readers interested in how the interpreter Egison executes pattern matching (including pattern-constructors) are recommend you to read the chapter <a href="./mechanism.html">Pattern Matching Mechanism</a>.
</p>

<hr/>
<p>
  [<a href="../index.html">Egison Top</a>]
  [<a href="./index.html">Egison Manual Top</a>]
</p>

</body>

<footer>
  <table width=100% border=0 cellspacing=0>
    <tr>
      <td align=left>
        <i>
          Copyright (C) 2011-2013 <a href="http://egi.pira.jp/index.html">Satoshi Egi</a>
        </i>
    </tr>
  </table>
</footer>

</html>
