<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Programming Language Egison Users Manual</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9772679-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>

<body>
<h1>Basics of Syntax and Semantics</h1>
<hr/>
<p>
  In this section, we run very simple Egison programs.<br/>
  We run Egison programs that do various pattern matching in the next section.<br/>
<hr/>

<h2>Top Expressions</h2>

<h3>Define and Test Expressions</h3>

<p>
  Give some input to Egison as below.<br/>
</p>

<pre>
  <code>
&gt; (define $x 2)
x
&gt; (test (+ x 3))
5
&gt; (define $f (lambda [$x $y] [(+ x y) (* x y)]))
&#14;f
&gt; (test (f x 4))
[6 8]
  </code>
</pre>

<p>
  There are two kinds of <i>top expressions</i> in above input, <code>define</code> expressions and <code>test</code> expressions.<br/>
  A <code>define</code> expression binds the value or the function to the variable.<br/>
  A <code>test</code> expression evaluates the given expression.<br/>
</p>

<h3>Load Expressions</h3>

<p>
  You can load Egison Libraries with <code>load</code> expressions.<br/>
</p>

<pre>
  <code>
&gt; (load "lib/graph.egi")
&gt; (load "lib/tree.egi")
  </code>
</pre>

<p>
  To load your own program, you can use <code>load-file</code> expressions.<br/>
  A <code>load-file</code> expression takes a full-path to the Egison program file.<br/>
</p>

<h2>Built-in Data</h2>

<p>
  Booleans, integers, float numbers, and characters are implemented as build-in data in Egison.<br/>
</p>

<h3>Booleans</h3>

<p>
  `<code>#t</code>' represents true.<br/>
  `<code>#f</code>' represents false.<br/>
</p>

<pre>
  <code>
#t
#f
  </code>
</pre>

<h3>Integers</h3>

<p>
  A string which consists from only numbers is a number literal.<br/>
</p>

<pre>
  <code>
1
0
-100
...
  </code>
</pre>

<h3>Floats</h3>

<p>
  A string which consists of numbers and contains `<code>.</code>' between numbers is a float literal.<br/>
</p>

<pre>
  <code>
1.0
0.0
-100.012001
...
  </code>
</pre>

<h3>Characters</h3>

<p>
  A character surrounded by single quote is a character literal.<br/>
</p>

<pre>
  <code>
'a'
'b'
'c'
...
  </code>
</pre>

<h3>Strings</h3>

<p>
  A line of characters surrounded by double quote is a string literal.<br/>
  Strings are treated as lists of characters.<br/>
</p>

<pre>
  <code>
"abc"
"cde\n"
...
  </code>
</pre>

<h2>Syntax of Egison</h2>

<h3>Inductive Data</h3>

<h3>Tuples (Multiple Values)</h3>

<pre>
  <code>
    [<i>value</i> ...]
  </code>
</pre>

<p>
A tuple is expressed as a sequence of elements enclosed in square brackets.<br/>
If a tuple consists of an element, the tuple and the element are the same.
</p>

<pre>
  <code>
[]
[1 2]
[#t "abc" 4]
[1]
  </code>
</pre>

<h3>Collections</h3>

<pre>
  <code>
    {<i>value</i> ...}
  </code>
</pre>

<p>
A collection is a sequence of elements enclosed in braces.<br/>
Unlike a tuple, a collection of an element and its unique element differ.<br/>
</p>

<pre>
  <code>
    {}
    {1 2}
    {#t "abc" 4}
    {1}
  </code>
</pre>

<p>
A collection may contain a collection as its element.<br/>
Generally, an element of a collection that is an element of a collection isn't an element of the outer collection.<br/>
But, <code>@</code> placed before a collection breaks the collection.<br/>
Then, an element of a collection with <code>@</code> that is an element of a collection is an element of the outer collection.<br/>
Using this notation, you can construct a collection from subcollections.
</p>

<pre>
  <code>
    &gt; (test {1 @{2 3}})
    {1 2 3}
    &gt; (test {@{@{1}} @{2 @{3}}})
    {1 2 3}
  </code>
</pre>

<h3><code>lambda</code> expressions</h3>

<pre>
  <code>
    (lambda [<i>variable</i> ...] <i>formula</i>)
  </code>
</pre>

<p>
Lambda expressions make functions as other functional programming languages.<br/>
It takes two arguments.<br/>
The first one is a tuple of variables, which are the dummy variables of the function.
Note <code>[$x]</code> and <code>$x</code> are the same.<br/>
The second argument is a formula, which is the body of the function.
</p>

<pre>
  <code>
    &gt; (test (lambda [$x $y] (+ x y)))
    (lambda [x y] ...)
    &gt; (test ((lambda [$x $y] (+ x y)) 3 7))
    10
    &gt; (test ((lambda $x (not x)) #t))
    #f
  </code>
</pre>

<h3><code>let</code> expressions</h3>

<pre>
  <code>
    (let {[<i>variable</i> <i>formula</i>] ...} <i>formula</i>)
  </code>
</pre>

<p>
A let expression takes two arguments.<br/>
The first argument is a collection of binary tuples, which are pairs of a variable and a formula.<br/>
These formulae will be evaluated when the associated variable is needed in an evaluation of the second argument, and bound to the variable.<br/>
Since a formula in the first argument is evaluated with the original environment, you can't use variables in the first argument in the formula.
</p>

<pre>
  <code>
    &gt; (test (let {[$x 1] [$y 2]} (+ x y)))
    3
    &gt; (test (let {[$x #t] [$y x]} (not x)))
    #f
    &gt; (test x)
    Unbound variable: x
  </code>
</pre>

<p>
Note the latter example works even if x is unbound, since Egison uses lazy evaluation.
</p>

<h3><code>letrec</code> expressions</h3>

<pre>
  <code>
    (letrec {[<i>variable</i> <i>formula</i>] ...} <i>formula</i>)
  </code>
</pre>

<p>
  A letrec expression is the same with a let expression except the fact that you can use recursive definition in the first argument.<br/>
  Mutual recursion is also allowed.
</p>

<pre>
  <code>
    &gt; (test (letrec {[$x #t] [$y x]} (not y)))
    #f
  </code>
</pre>

<h3><code>if</code> expressions</h3>

<pre>
  <code>
    (if <i>boolean</i> <i>formula</i> <i>formula</i>)
  </code>
</pre>

<p>
  It's ordinary <code>if</code>.<br/>
  But, note the result of an evaluation of the first argument must be a boolean (i.e. <code>#t</code> or <code>#f</code>).<br/>
</p>

<pre>
  <code>
    &gt; (test (if #f "YES" "NO"))
    NO
    &gt; (test (if #t 1 ((lambda $x (x x)) (lambda $x (x x)))))
    1
  </code>
</pre>

<h3><code>match</code> expressions</h3>

<pre>
  <code>
    (match <i>formula</i> <i>matcher</i> {[<i>pattern</i> <i>formula</i>] ...})
  </code>
</pre>

<p>
This expression do pattern matching of the first argument.<br/>
The fist argument is regarded as a data of the second argument and compared with the patterns of the third argument.<br/>
When it matches a pattern in the third argument, the associated formula will be evaluated.<br/>
If the pattern includes pattern variables, variables are locally bound and the formula will be evaluated with the variables.<br/>
This binding isn't necessarily unique.<br/>
But, unlike the below, this expression returns just one of the cases.
</p>

<pre>
  <code>
    &gt; (test (match {1 2 3 4} (list integer) {[&lt;nil&gt; #f] [&lt;cons $x $xs&gt; [x xs]]}))
    [1 {2 3 4}]
    &gt; (test (match {1 2 3 4} (set integer) {[&lt;nil&gt; #f] [&lt;cons $x $xs&gt; [x xs]]}))
    [1 {1 2 3 4}]
  </code>
</pre>

<h3><code>match-all</code> expressions</h3>

<pre>
  <code>
    (match-all <i>formula</i> <i>matcher</i> [<i>pattern</i> <i>formula</i>])
  </code>
</pre>

<p>
  Like a <code>match</code> expression, a <code>match-all</code> expression also do pattern matching.<br/>
  However, this expression returns all cases of binding.
  For the details, see the next section.
</p>

<pre>
  <code>
    &gt; (test (match-all {1 2 3 4} (list integer) [&lt;cons $x $xs&gt; [x xs]]))
    [1 {2 3 4}]
    &gt; (test (match-all {1 2 3 4} (set integer) [&lt;nil&gt; #f] [&lt;cons $x $xs&gt; [x xs]]))
    {[1 {1 2 3 4}] [2 {1 2 3 4}] [3 {1 2 3 4}] [4 {1 2 3 4}]}
  </code>
</pre>

<h3><code>matcher</code> expressions</h3>

<h3><code>function</code> expressions</h3>

<pre>
  <code>
    (function <i>matcher</i> {[<i>pattern</i> <i>formula</i>] ...})
  </code>
</pre>

<p>
Like a lambda expression, a function expression creates a function with an arugment.<br/>
Pattern matching is done with the argument.<br/>
Roughly speaking,
<code>
(function <i>X</i> {[<i>Y</i> <i>Z</i>] ...})
</code>
and
<code>
(lambda [$x] (match x <i>X</i> {[<i>Y</i> <i>Z</i>] ...}))
</code>
are the same.
</p>

<pre>
  <code>
    &gt; (test (letrec {[$count (function (list something) {[&lt;nil&gt; 0] [&lt;cons _ $xs&gt; (+ (count xs) 1)]})]} (count {1 2 3})))
    3
  </code>
</pre>

<h3><code>apply</code> expressions</h3>

<pre>
  <code>
    (apply <i>function</i> [<i>value</i> ...])
  </code>
</pre>

If you have a function and its arguments as a tuple, and want to get the result of the application, then you should use this expression.<br/>
The result of the evaluation of an apply expression is the result of application of the function with the arguments.<br/>
That is, <code>(apply f [x<sub>0</sub> x<sub>1</sub> x<sub>2</sub>])</code> is the same thing with <code>(f x<sub>0</sub> x<sub>1</sub> x<sub>2</sub>)</code>.

<h3>Patterns</h3>

Patterns form the basis of Egison.<br/>
Since they are first-class objects, you can regard patterns as values.

<h4>Pattern Variables</h4>

<pre>
  <code>
    <i>variable</i>
  </code>
</pre>

<p>
You can use varibales as patterns.
These patterns are called "pattern variables".<br/>
Any object matches this pattern, and then the variable is locally bound.<br/>
Moreover, you can use the pattern in inductive patterns.<br/>
This usage allows us to deconstruct an object.
</p>

<pre>
  <code>
    &gt; (test (match 1 something {[$x x]}))
    1
    &gt; (test (match #t something {[$z (not z)]}))
    #f
    &gt; (test (match {1 2 3} (list integer) {[&lt;nil&gt; #f] [&lt;cons $x $xs&gt; [x xs]]}))
    [1 {2 3}]
    &gt; (test (match {1} (list integer) {[&lt;nil&gt; #f] [&lt;cons $x $xs&gt; [x xs]]}))
    [1 {}]
  </code>
</pre>

<h4>Value Patterns</h4>

<pre>
  <code>
    ,<i>value</i>
  </code>
</pre>

<p>
  A value pattern is a pattern that paticular objects match.<br/>
  You should not forget to place COMMA before a value.
</p>

<pre>
  <code>
    &gt; (test (match 1 integer {[,1 &lt;OK&gt;] [_ &lt;KO&gt;]}))
    &lt;OK&gt;
    &gt; (test (match 0 integer {[,1 &lt;OK&gt;] [_ &lt;KO&gt;]}))
    &lt;KO&gt;
    &gt; (test (match {1 2 3} (list integer) {[,{1 2 3} &lt;OK&gt;] [_ &lt;KO&gt;]}))
    &lt;OK&gt;
    &gt; (test (match {1 2 3} (list integer) {[&lt;cons _ &lt;cons ,2 _&gt;&gt; &lt;OK&gt;] [_ &lt;KO&gt;]}))
    &lt;OK&gt;
    &gt; (test (match {1 4 3} (list integer) {[&lt;cons _ &lt;cons ,2 _&gt;&gt; &lt;OK&gt;] [_ &lt;KO&gt;]}))
    &lt;KO&gt;
  </code>
</pre>

<!-- <h4>Cut-Patterns</h4> -->

<!-- <h4>Not-Patterns</h4> -->

<h4>And-Patterns</h4>

<pre>
  <code>
    (& <i>pattern</i> ...)
  </code>
</pre>

<p>
When you have patterns, you sometimes want to get a pattern that is matched, if and only if, all of the patterns are matched.<br/>
Such a pattern is called "and-pattern".
</p>

<pre>
  <code>
    (& &lt;cons ,1 _&gt; &lt;snoc ,2 _&gt;)
    (&)
  </code>
</pre>

<pre>
  <code>
    &gt; (test (match {1 3 2} (list integer) {[&lt;cons ,1 _&gt; &lt;OK&gt;] [_ &lt;KO&gt;]}))
    &lt;OK&gt;
    &gt; (test (match {1 3 2} (list integer) {[&lt;snoc ,2 _&gt; &lt;OK&gt;] [_ &lt;KO&gt;]}))
    &lt;OK&gt;
    &gt; (test (match {1 3 2} (list integer) {[(& &lt;cons ,1 _&gt; &lt;snoc ,2 _&gt;) &lt;OK&gt;] [_ &lt;KO&gt;]}))
    &lt;OK&gt;
    &gt; (test (match {1 3 3} (list integer) {[&lt;snoc ,2 _&gt; &lt;OK&gt;] [_ &lt;KO&gt;]}))
    &lt;KO&gt;
    &gt; (test (match {1 3 3} (list integer) {[(& &lt;cons ,1 _&gt; &lt;snoc ,2 _&gt;) &lt;OK&gt;] [_ &lt;KO&gt;]}))
    &lt;KO&gt;
    &gt; (test (match #t something {[(&) &lt;OK&gt;] [_ &lt;KO&gt;]}))
    &lt;OK&gt;
  </code>
</pre>

<p>
  The most common usage of and-pattern is "matching and binding".<br/>
  When you need to get a value matched the pattern, it is useful.<br/>
  For example, any non-empty list matches the following and-pattern, and is bound to the variable "xs".
</p>

<pre>
  <code>
    (& &lt;cons _ _&gt; $xs)
  </code>
</pre>

<pre>
  <code>
    &gt; (test (match {1 2} (list integer) {[(& &lt;cons _ _&gt; $xs) xs] [_ #f]}))
    {1 2}
    &gt; (test (match {} (list integer) {[(& &lt;cons _ _&gt; $xs) xs] [_ #f]}))
    #f
  </code>
</pre>

<h4>Or Patterns</h4>

<pre>
  <code>
    (| <i>pattern</i> ...)
  </code>
</pre>

<p>
  Or-patterns are the dual of and-patterns.</br>
  If you want to get an object that matches one of given patterns, you should use or-pattern.
</p>

<pre>
  <code>
    (| 1 2 3)
    (| #t #f)
    (|)
  </code>
</pre>

<pre>
  <code>
    &gt; (test (match {1 3 3} (list integer) {[(| &lt;cons ,1 _&gt; &lt;snoc ,2 _&gt;) &lt;OK&gt;] [_ &lt;KO&gt;]}))
    &lt;OK&gt;
    &gt; (test (match #t something {[(|) &lt;OK&gt;] [_ &lt;KO&gt;]}))
    &lt;KO&gt;
  </code>
</pre>

<p>
  The following is an interesting example of or-pattern.
  <code>(f)</code> is the pattern that any collection consisting of 1 matches.
</p>

<pre>
  <code>
    &gt; (define $f (pattern-constructor [] (| &lt;nil&gt; &lt;cons ,1 (f)&gt;)))
    &gt; (test (match-all {1} (list integer) [(f) &lt;OK&gt;]))
    {&lt;OK&gt;}
    &gt; (test (match-all {1 1 1 1 1 1} (list integer) [(f) &lt;OK&gt;]))
    {&lt;OK&gt;}
    &gt; (test (match-all {} (list integer) [(f) &lt;OK&gt;]))
    {&lt;OK&gt;}
    &gt; (test (match-all {1 1 1 2 1 1} (list integer) [(f) &lt;OK&gt;]))
    {}
  </code>
</pre>

<hr/>

<p>
  [<a href="../index.html">Egison Top</a>]
  [<a href="./index.html">Egison Manual Top</a>]
</p>

</body>

<footer>
  <hr size=1 noshade>
  <table width=100% border=0 cellspacing=0>
    <tr>
      <td align=right>
        <i>
          <a href="http://egi.pira.jp">Egi Satoshi</a>
        </i>
    </tr>
  </table>
</footer>

</html>
