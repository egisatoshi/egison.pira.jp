<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Programming Language Egison Users Manual</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9772679-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>

<body>
<h1>Basics of Syntax and Semantics</h1>
<hr/>
<p>
  In this and the next chapters, we briefly explain the syntax of Egison.
  This chapter explains an aspect of Egison as an ordinal purely functional programming language.
  We will explain patterns and pattern-matching, the most important feature of Egison in the next chapter.
  The readers familiar to other functional programming languages can skip this chapter.
<hr/>

<h2>Top Expressions</h2>

<h3>Define and Test Expressions</h3>

<p>
  Give some input to Egison as below.<br/>
</p>

<pre><code>&gt; (define $x 2)
&gt; (test (+ x 3))
5
&gt; (define $f (lambda [$x $y] [(+ x y) (* x y)]))
&gt; (test (f x 4))
[6 8]</code></pre>

<p>
  There are two kinds of <i>top expressions</i> in above input, <code>define</code> expressions and <code>test</code> expressions.<br/>
  A <code>define</code> expression binds the value or the function to the variable.<br/>
  A <code>test</code> expression evaluates the given expression.<br/>
</p>

<h3>Load Expressions</h3>

<p>
  You can load Egison Libraries with <code>load</code> expressions.<br/>
</p>

<pre><code>&gt; (load "lib/core/base.egi")
&gt; (load "lib/core/number.egi")
&gt; (load-file "/home/xxx/code/egison/myfile.egi")</code></pre>

<p>
  To load your own program, you can use <code>load-file</code> expressions.<br/>
  A <code>load-file</code> expression takes a full-path to the Egison program file.<br/>
</p>

<h3>Execute Expressions</h3>

<p>
  Like other programming language, you can manipulate IO via Egison.
  In such a purpose, <code>execute</code> expressions are used.
  To explain the expression, we need to explain IO in Egison.
  We will do at another chapter.
</p>

<h2>Built-in Data</h2>

<p>
  Booleans, integers, float numbers, and characters are implemented as built-in data in Egison.
</p>

<h3>Booleans</h3>

<p>
  `<code>#t</code>' represents true.<br/>
  `<code>#f</code>' represents false.<br/>
</p>

<pre><code>#t
#f</code></pre>

<h3>Integers</h3>

<p>
  A string which consists of only numbers is a number literal.<br/>
  An integer literal is a number literal or concatenation of `-' and a number literal.
</p>

<pre><code>1
0
-100
...</code></pre>

<h3>Floats</h3>

<p>
  A floating-point literal is concatenation of an integer literal, `<code>.</code>', and a number literal.
</p>

<pre><code>1.0
0.0
-100.012001
...</code></pre>

<h3>Characters</h3>

<p>
  A character literal is a character enclosed in single quotes.
</p>

<pre><code>'a'
'b'
'c'
...</code></pre>

<h3>Strings</h3>

<p>
  A string literal is a string enclosed in double quotes.<br/>
  It is treated as a list of characters.
</p>

<pre><code>"abc"
"cde\n"
...</code></pre>

<h3>Undefined</h3>

<p>
  As shown follows, you can use an array in Egison.
  Moreover, you can access any index in an array, even if it is out of range of array.
  For example, you can try to get the 123456th element of an array whose size is 10.
  In such a case, you get <code>undefined</code>.
  Of course, you can use <code>undefined</code> in any other case.
</p>

<pre><code>undefined</code></pre>

<h2>Objects</h2>

<h3>Five Enclosures</h3>

<p>
First of all, we explain the enclosures of Egison.
Perhaps you are surprised at how many kinds of enclosures in Egison when you first see code of Egison.
In Egison, there are five kinds of enclosures, i.e. parentheses `()', brackets `<>', square brackets `[]', braces `{}', and double brackets `[||]'.
They represents procedure call, an <a href="#inductive-data">inductive datum</a>, a <a href="#tuple">tuple</a>, a <a href="#collection">collection</a>, and an <a href="#array">array</a>.
Roughly speaking, you should use parentheses as LISP, brackets when you want to create patterns or your own data, and double brackts to create an array.
Square brackets and braces are both used to collect values.
The difference between them is the number of values.
The former are used to collect the fixed number of values, but the latter are used to collect the others.
</p>

<h3 id="inductive-data">Inductive Data</h3>

<pre><code>  &lt;<i>Identifier</i> <i>value</i> ...&gt;</code></pre>

<p>
  You can create an object whose name you want.
  It is called an inductive datum.<br/>
  An inductive datum can have values.
  In particular, it can have any inductive data.
  This is why it is called "inductive".<br/>
  Note that the name has to start with uppercase.
</p>

<pre><code>&lt;A&gt;
&lt;Abc 1 #t "Hello, World!\n"&gt;
&lt;Cons &lt;Cons &lt;Nil&gt;&gt; &lt;Nil&gt;&gt;</code></pre>

<h3 id="tuple">Tuples (Multiple Values)</h3>

<pre><code>  [<i>value</i> ...]</code></pre>

<p>
A tuple is expressed as a sequence of elements enclosed in square brackets.<br/>
If a tuple consists of an element, the tuple and the element are the same.
</p>

<pre><code>[]
[1 2]
[#t "abc" 4]
[1]</code></pre>

<h3 id="collection">Collections</h3>

<pre><code>  {<i>value</i> ...}</code></pre>

<p>
A collection is a sequence of elements enclosed in braces.<br/>
Unlike a tuple, a collection of an element and its unique element differ.<br/>
</p>

<pre><code>{}
{1 2}
{#t "abc" 4}
{1}</code></pre>

<p>
A collection may contain a collection as its element.<br/>
Generally, an element of a collection that is an element of a collection isn't an element of the outer collection.<br/>
But, <code>@</code> placed before a collection breaks the collection.<br/>
Then, an element of a collection with <code>@</code> that is an element of a collection is an element of the outer collection.<br/>
Using this notation, you can construct a collection from subcollections.
</p>

<pre><code>&gt; (test {1 @{2 3}})
{1 2 3}
&gt; (test {@{@{1}} @{2 @{3}}})
{1 2 3}</code></pre>

<h3 id="array">Array</h3>

<p>
</p>

<h2>Syntax of Egison</h2>

<h3><code>lambda</code> expressions</h3>

<pre><code>  (lambda [<i>variable</i> ...] <i>formula</i>)</code></pre>

<p>
Lambda expressions make functions as other functional programming languages.<br/>
It takes two arguments.<br/>
The first one is a tuple of variables, which are the dummy variables of the function.
Note <code>[$x]</code> and <code>$x</code> are the same.<br/>
The second argument is a formula, which is the body of the function.
</p>

<pre><code>&gt; (test (lambda [$x $y] (+ x y)))
(lambda [x y] ...)
&gt; (test ((lambda [$x $y] (+ x y)) 3 7))
10
&gt; (test ((lambda $x (not x)) #t))
#f</code></pre>

<p>
  From ver.3.0, a lambda expression is equipped with simpler notation.<br/>
  In this notation, you can omit to write "lambda" and the arguments of the function.<br/>
  You can refer to the i-th argument by writing concatenation of <code>$</code> and i.<br/>
  If the order of occurrences of the arguments is the same as the order of the arguments and their occurrences are exactly one, then you can omit a number after <code>$</code>.<br/>
  That is, <code>(lambda [$x $y] (+ x y))</code>, <code>(+ $1 $2)</code>, and <code>(+ $ $)</code> are the same.<br/>
  Although this notation is so powerful, it is limited to specific functions.<br/>
  The body of such a function has to be simple.<br/>
  Namely, it is application of a function and its arguments, and all occurrences of <code>$i</code> are the arguments.<br/>
  For example, you can't write <code>(+ $1 (* $2 2))</code> or <code>(if $1 #f #t)</code>
</p>

<pre><code>&gt; (test ((+ $1 $2) 3 4))
7
&gt; (test ((+ $ $) 3 4))
7
&gt; (test ((* $1 $1) 5))
25
&gt; (test ((map $2 $1) {1 2 3} (+ $ 1)))
{2 3 4}</code></pre>

<h3><code>let</code> expressions</h3>

<pre><code>  (let {[<i>variable</i> <i>formula</i>] ...} <i>formula</i>)</code></pre>

<p>
A let expression takes two arguments.<br/>
The first argument is a collection of binary tuples, which are pairs of a variable and a formula.<br/>
These formulae will be evaluated when the associated variable is needed in an evaluation of the second argument, and bound to the variable.<br/>
Since a formula in the first argument is evaluated with the original environment, you can't use variables in the first argument in the formula.
</p>

<pre><code>&gt; (test (let {[$x 1] [$y 2]} (+ x y)))
3
&gt; (test (let {[$x #t] [$y x]} (not x)))
#f
&gt; (test x)
Unbound variable: x</code></pre>

<p>
Note the latter example works even if x is unbound, since Egison uses lazy evaluation.
</p>

<h3><code>letrec</code> expressions</h3>

<pre><code>  (letrec {[<i>variable</i> <i>formula</i>] ...} <i>formula</i>)</code></pre>

<p>
  A letrec expression is the same as a let expression except the fact that you can use recursive definition in the first argument.<br/>
  Mutual recursion is also allowed.
</p>

<pre><code>&gt; (test (letrec {[$x #t] [$y x]} (not y)))
#f</code></pre>

<h3><code>if</code> expressions</h3>

<pre><code>  (if <i>boolean</i> <i>formula</i> <i>formula</i>)</code></pre>

<p>
  It's ordinary <code>if</code>.<br/>
  But, note the result of an evaluation of the first argument must be a boolean (i.e. <code>#t</code> or <code>#f</code>).<br/>
</p>

<pre><code>&gt; (test (if #f "YES" "NO"))
NO
&gt; (test (if #t 1 ((lambda $x (x x)) (lambda $x (x x)))))
1</code></pre>

<h3><code>apply</code> expressions</h3>

<pre><code>  (apply <i>function</i> [<i>value</i> ...])</code></pre>

If you have a function and its arguments as a tuple, and want to get the result of the application, then you should use this expression.<br/>
The result of the evaluation of an apply expression is the result of application of the function with the arguments.<br/>
That is, <code>(apply f [x<sub>0</sub> x<sub>1</sub> x<sub>2</sub>])</code> is the same thing as <code>(f x<sub>0</sub> x<sub>1</sub> x<sub>2</sub>)</code>.

<pre><code>&gt; (test (apply + [1 2]))
3</code></pre>

<hr/>
<p>
  [<a href="../index.html">Egison Top</a>]
  [<a href="./index.html">Egison Manual Top</a>]
</p>

</body>

<footer>
  <table width=100% border=0 cellspacing=0>
    <tr>
      <td align=left>
        <i>
          Copyright (C) 2011-2013 <a href="http://egi.pira.jp/index.html">Satoshi Egi</a>
        </i>
    </tr>
  </table>
</footer>

</html>
