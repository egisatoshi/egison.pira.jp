<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Programming Language Egison Users Manual</title>
<meta http-equiv="Content-Matcher" content="text/html;charset=UTF-8" />
</head>

<body>
<h1>How to Define Matchers</h1>
<hr/>
<p>
  As described in previous sections, matchers define how to do pattern matching.
  In this section, we explain how to define matchers using libraries as examples.
</p>
<hr/>

<h2>Formal Definition of <code>matcher</code></h2>

<p>
You can define a matcher using <code>matcher</code>.
First of all, we show the formal definition of <code>matcher</code>.
</p>

<pre>
  <code>
    &lt;matcher-sentence&gt;          := `(' matcher `{' &lt;primitive-pattern-clause&gt;* `}' `)'
    &lt;primitive-pattern-clause&gt;  := `[' &lt;primitive-pp&gt; `[' &lt;matcher&gt;* `]' `{' &lt;primitive-data-clause&gt;* `}' `]'
    &lt;primitive-data-clause&gt;     := `[' &lt;primitive-dp&gt; &lt;body&gt; `]'
    &lt;primitive-pp&gt;              := `$'                                             (primitive-pattern-variable)
                                 | `,$' &lt;identifier&gt;                               (value-pattern-pattern)
                                 |  `&lt;' &lt;identifier&gt; &lt;primitive-pp&gt;* `&gt;'           (primitive-inductive-pattern)
    &lt;primitive-dp&gt;              := `_'                                             (wildcard)
                                 | `$' &lt;identifier&gt;                                (primitive-data-variable)
                                 | `&lt;' &lt;Identifier&gt; &lt;primitive-dp&gt;* `&gt;'            (primitive-inductive-data)
                                 | `{}'                                            (primitive-null-collection)
                                 | `{' &lt;primitive-dp&gt; @&lt;primitive-dp&gt; `}'          (primitive-cons-collection)
                                 | `{' @&lt;primitive-dp&gt; &lt;primitive-dp&gt; `}'          (primitive-snoc-collection)
  </code>
</pre>

<p>
Here, <code>&lt;body&gt;</code> is a formula of Egison.
<code>&lt;primitive-pp&gt;</code> and <code>&lt;primitive-dp&gt;</code> are abbreviations of <code>&lt;primitive-pattern-pattern&gt;</code> and <code>&lt;primitive-data-pattern&gt;</code>, respetively.
</p>

<h2>Definitions of Simple Matchers</h2>

<p>
A matcher determines how to do pattern matching.
Generally speaking, given a pattern and an object, a matcher returns the candidates of <code>match-all</code> with the pattern and the object.
<code>match</code> returns one of them, if it isn't null.
Given a pattern and an object, what Egison do is the following.
<ol>
<li>Find a <code>&lt;primitive-pattern-pattern&gt;</code> matched by the pattern.
If the <code>&lt;primitive-pattern-pattern&gt;</code> contains pattern variables, the associated value in the pattern is bound.
</li>
<li>
If found, find a <code>&lt;primitive-data-pattern&gt;</code> in the associated <code>&lt;primitive-data-clause&gt;</code> matched by the object.
If the <code>&lt;primitive-data-pattern&gt;</code> contains pattern variables, the associated value in the object is bound.
</li>
<li>
If found, returns the result of an evaluation the associated <code>&lt;body&gt;</code>
</li>
</ol>

In the subsection, we explain the basics of matcher using <code>ordering</code>.
</p>

<pre>
  <code>
(define $ordering
  (matcher
    {[,$val []
      {[$tgt (match [val tgt] [ordering ordering]
               {[[&lt;less&gt; &lt;less&gt;] {[]}]
                [[&lt;equal&gt; &lt;equal&gt;] {[]}]
                [[&lt;greater&gt; &lt;greater&gt;] {[]}]
                [_ {}]})]}]
     [&lt;less&gt; []
      {[&lt;Less&gt; {[]}]
       [_ {}]}]
     [&lt;equal&gt; []
      {[&lt;Equal&gt; {[]}]
       [_ {}]}]
     [&lt;greater&gt; []
      {[&lt;Greater&gt; {[]}]
       [_ {}]}]
     [$ [something]
      {[$tgt {tgt}]}]
     }))
  </code>
</pre>

<p>
Note that we use neither <code>(primitive-null-collection)</code>, <code>(primitive-cons-collection)</code>, nor <code>(primitive-snoc-collection)</code>, in the definition of <code>ordering</code>.
They are described in the next subsection.
</p>

<p>
We start to explain the behaviour from step 1 in the above list.
In the step, Egison examines whether the pattern matches a <code>&lt;primitive-pattern-pattern&gt;</code> or not.
See the definitions of <code>&lt;primitive-pattern-pattern&gt;</code>.
Any value pattern and inductive pattern match <code>(value-pattern-pattern)</code> and <code>(primitive-inductive-pattern)</code>, respectively.
<code>(primitive-pattern-variable)</code> is matched by any pattern.
For example, consider evaluating the following code.
</p>

<pre>
  <code>
    (match-all &lt;Equal&gt; ordering [,&lt;Less&gt; #t])
    (match-all &lt;Equal&gt; ordering [,&lt;Equal&gt; #t])
    (match-all &lt;Equal&gt; ordering [&lt;equal&gt; #t])
    (match-all &lt;Equal&gt; ordering [$x x])
  </code>
</pre>

<p>
Since the patterns in the first two piece of code are both value patterns, they match <code>,$val</code>.
Then, <code>&lt;Less&gt;</code> and <code>&lt;Equal&gt;</code> are bound to <code>val</code>.
In the third case, <code>&lt;equal&gt;</code> matches neither <code>,$val</code> nor <code>&lt;less&gt;</code>, but <code>&lt;equal&gt;</code>, because they are exactly the same.
In the last one, <code>$x</code> matches the last <code>primitive-pattern-pattern</code>, namely, <code>$</code>.
</p>

<p>
Let's move to the step 2.
Like the step 1, Egison examines whether the object matches a <code>&lt;primitive-data-pattern&gt;</code> or not, in the step.
</p>

<hr/>

<p>
Egison provides syntactic sugar <code>algebraic-data-matcher</code> for such a deinition of a matcher.
Actually, in the library "base.egi", the matcher <code>ordering</code> is defined using <code>algebraic-data-matcher</code>.
The following code has the same meaning with the above definition of <code>ordering</code>.
</p>

<pre>
  <code>
(define $ordering
  (algebraic-data-matcher 
    (| &lt;less&gt; &lt;equal&gt; &lt;greater&gt;)))
  </code>
</pre>

<h2>Definitions for Collection Data Matchers</h2>

In this section, I'll explain matcher definitions of lists, multisets, and sets.

<pre>
<code>
(define $list
  (lambda [$a]
    (matcher
      {[,$val []
        {[$tgt (match [val tgt] [(list a) (list a)]
                 {[[&lt;nil&gt; &lt;nil&gt;] {[]}]
                  [[&lt;cons $x $xs&gt; &lt;cons ,x ,xs&gt;] {[]}]
                  [[_ _] {}]})]}]
       [&lt;nil&gt; []
        {[{} {[]}]
         [_ {}]}]
       [&lt;cons $ $&gt; [a (list a)]
        {[{$x @$xs} {[x xs]}]
         [_ {}]}]
       [&lt;snoc $ $&gt; [a (list a)]
        {[{@$xs $x} {[x xs]}]
         [_ {}]}]
       [&lt;join ,$pxs $&gt; [(list a)]
        {[$tgt (letrec {[$helper (lambda [$pxs $tgt]
                                   (match [pxs tgt] [(list a) (list a)]
                                     {[[&lt;nil&gt; _] {tgt}]
                                      [[&lt;cons $x $xs&gt; &lt;cons ,x $ys&gt;] (helper xs ys)]
                                      [[_ _] {}]}))]}
                 (helper pxs tgt))]}]
       [&lt;join $ $&gt; [(list a) (list a)]
        {[$tgt (letrec {[$helper (lambda [$xs $ys]
                                   (match ys (list a)
                                     {[&lt;nil&gt; {[xs {}]}]
                                      [&lt;cons $z $zs&gt; {[xs ys] @(helper {@xs z} zs)}]}))]}
                 (helper {} tgt))]}]
       [&lt;nioj ,$pxs $&gt; [(list a)]
        {[$tgt (match-all tgt (list a) [&lt;join $ys ,pxs&gt; ys])]}]
       [&lt;nioj $ $&gt; [(list a) (list a)]
        {[$tgt (letrec {[$helper (lambda [$xs $ys]
                                   (match ys (list a)
                                     {[&lt;nil&gt; {[{} xs]}]
                                      [&lt;cons $z $zs&gt; {[ys xs] @(helper {@xs z} zs)}]}))]}
                 (helper {} tgt))]}]
       [$ [something]
        {[$tgt {tgt}]}]
       })))
</code>
</pre>

<p>
  <code>list</code> is defined as a function that gets a matcher and returns a matcher.<br/>
  The argument matcher is the matcher for elements of lists.<br/>
  Therefore, <code>(list integer)</code> means a matcher of a list of integers, and <code>(list (list integer))</code> means a matcher of a list of lists of integers.<br/>
</p>

<p>
  A <code>matcher</code> expression defines a matcher.<br/>
  The pattern matching process of Egison is recursively defined.<br/>
  The input of the pattern matching process are a pattern, a target, and a matcher, and the pattern matching process decompose the input pattern and target according to the matcher definition.<br/>
  The decomposed patterns and targets are passed to next pattern matching process with the matchers that is specified in the matcher definition.<br/>
  A <code>matcher</code> expression defines the way of destruction of each one step in whole recursive destruction.<br/>
  You can see pattern matching process samples in <a href="./mechanism.html">next section</a>.<br/>
</p>

<p>
  A <code>matcher</code> expression is constituted of a collection of <i>primitive-pattern-clauses</i>.<br/>
  A primitive-pattern-clause is a tuple of a <i>primitive-pattern-pattern</i>, a <i>next-matcher-expression</i> and a collection of <i>primitive-data-clauses</i>.<br/>
</p>

<p>
  A <i>primitive-pattern-pattern</i> is a pattern for patterns.<br/>
  The pattern is pattern matched with the primitive-pattern-patterns from the head of the primitive-pattern-clauses.<br/>
  If one of the primitive-pattern-pattern is matched with the pattern, 
  the primitive-pattern-clauses of that primitive-pattern-pattern is used to get the targets and the matchers for next pattern matching.<br/>
</p>

<pre>
<code>
&lt;primitive-pp&gt; ::= `$'                                (primitive pattern variable)
                 | `,$' var-name                      (value-pat pattern)
                 |  `&lt;' cons-name &lt;primitive-pp&gt;* `&gt;' (primitive inductive pattern)
</code>
</pre>

<p>
  Here is syntax of <i>primitive-pattern-patterns</i>.<br/>
  A primitive-pattern-pattern is an inductive data whose element is a `<code>$</code>' or a value-pattern pattern.<br/>
  A primitive-pattern-pattern which is enclosed with `<code>&lt;</code>' and `<code>&gt;</code>' matches with the inductive pattern whose pattern constructor is same.<br/>
</p>

<p>
  An value-pattern-pattern is matched with the value pattern and bind its value to <code>var-name</code>.<br/>
  These bindings are used in the evaluation of the primitive-data-clause.<br/>
</p>

<p>
  `<code>_</code>' is matched with any pattern, and the pattern which is matched with the wildcard is passed as the pattern for next pattern matching.<br/>
</p>

<p>
  A primitive-data-clause is constituted of <i>primitive-data-pattern</i> and a body expression which is evaluated to next pattern matching targets.<br/>
  The way of Pattern matching of primitive-data-pattern is same with the ordinary pattern matching.<br/>
  It has only one result, and not allow repeated pattern variables.<br/>
  Here is syntax of primitive data patterns.<br/>
</p>

<pre>
<code>
&lt;primitive-dp&gt; ::= `_'
                 | `$' var-name
                 | `&lt;' cons-name &lt;primitive-dp&gt;* `&gt;'
                 | `{}'
                 | `{' &lt;primitive-dp&gt; .&lt;primitive-dp&gt;  `}'
                 | `{' .&lt;primitive-dp&gt; &lt;primitive-dp&gt;  `}'
</code>
</pre>

<p>
  '<code>_</code>' is a <i>primitive wild card</i>.<br/>
  It matches with any values.<br/>
</p>

<p>
  A pattern variable which appears in the primitive pattern is a <i>primitive pattern variable</i>.<br/>
  It matches with any value, and the value is bound to it.<br/>
</p>

<p>
  <code>&lt;cons-name &lt;primitive-dp&gt;*&gt;</code> is a <i>primitive inductive pattern</i>.<br/>
  This pattern matches when the target value is an inductive value whose constructor is the same with <code>cons-name</code>.<br/>
  Pattern matchings for each argument are recursively executed.<br/>
</p>

<p>
  <code>{}</code> is a <i>primitive empty pattern</i>.<br/>
  This pattern matches when the target value is an empty collection.<br/>
</p>

<p>
  <code>{&lt;primitive-dp&gt; .&lt;primitive-dp&gt;}</code> is a <i>primitive cons pattern</i>.<br/>
  This pattern matches when the target collection contain more than one element.<br/>
  The first <code>primitive-dp</code> is matched with the first element of the target collection, and the second <code>primitive-dp</code> is matched with the rest elements of the target collection.<br/>
</p>

<p>
  <code>{.&lt;primitive-dp&gt; &lt;primitive-dp&gt;}</code> is a <i>primitive snoc pattern</i>.<br/>
  This pattern matches when the target collection contain more than one element.<br/>
  The second <code>{primitive-dp} is matched with the last element of the target collection, and the first <code>primitive-dp</code> is matched with the rest elements of the target collection.<br/>
</p>

<p>
  These three primitive patterns are the primitive operation for collections.<br/>
  All operations for collections derive from these.<br/>
  Collections are matched as a list in primitive pattern matching.<br/>
</p>

<p>
  Now, I've explained all components of matcher expressions.<br/>
  Then, we walk through how patterm matching proceed with an example.<br/>
  Let's consider the case that the matcher is <code>(list integer)</code>,
  the pattern is <code>&lt;join $xs &lt;cons _ $ys&gt;&gt;</coee>,
and the target is <code>{1 2 3}</code>.<br/>
</p>

<p>
  The both argument pattern constructor <code>join</code> is not a value pattern.<br/>
  So, the primitive-pattern-pattern of sixth primitive-pattern-clause <code>&lt;join _ _&gt;</code> is matched with the input pattern.<br/>
  First `<code>_</code>' of the primitive-pattern-pattern is matched with <code>$xs</code>,
  and second `<code>_</code>' of the primitive-pattern-pattern is matched with <code>&lt;cons _ $ys&gt;</code>.<br/>
  Therefore <code>$xs</code> and <code>&lt;cons _ $xs&gt;</code> are passed to next pattern matching process as next patterns.<br/>
</p>

<p>
  The next-matcher-expression of matched matcher-clause is <code>[(list a) (list a)]</code>,
  and <code>a</code> is bound to <code>integer</code>.<br/>
  Therefore  <code>(list integer)</code> and <code>(list integer)</code> are passed to next pattern matching process as next matchers.<br/>
</p>

<p>
  The primitive-match-cluases return a collection of next matchers.<br/>
  The primitive-match-cluases of this matcher-caluse has only one prmitive-match-cluase.<br/>
  The primitive-data-pattern of this primitive-data-clause is <code>$tgt</code>,
  and it is matched with and bound to the target data <code>{1 2 3}</code>.<br/>
  The body of primitive-data-clause is evaluated and it returns
  <code>{[{} {1 2 3}] [{1} {2 3}] [{1 2} {3}] [{1 2 3} {}]}</code>.<br/>
  All elements of this collection are passed to next pattern mathing as next targets.<br/>
  There are multiple ways to destruct the collection with <code>join</code> pattern constructor.<br/>
  Pattern matching process are recursively executed for all these destruction.<br/>
</p>

<p>
  Next matchers, next patterns, and next targets have same number of elements.<br/>
  That is, the first next targets are <code>[{} {1 2 3}]</code>, so the <code>{}</code> is matched with the pattern <code>$xs</code> as <code>(list integer)</code>,
  and the <code>{1 2 3}</code> is matched with the pattern <code>&lt;cons _ $xs&gt;</code> as <code>(list integer)</code>, in next pattern matching.<br/>
</p>

<p>
...
</p>

<p>
  The difference between the <code>join</code> and <code>nioj</code> pattern constructor is the order of evaluation of pattern matching process.
</p>

<pre>
<code>
(define $multiset
  (lambda [$a]
    (matcher
      {[,$val []
        {[$tgt (match [val tgt] [(list a) (multiset a)]
                 {[[&lt;nil&gt; &lt;nil&gt;] {[]}]
                  [[&lt;cons $x $xs&gt; &lt;cons ,x ,xs&gt;] {[]}]
                  [[_ _] {}]})]}]
       [&lt;nil&gt; []
        {[{} {[]}]
         [_ {}]}]
       [&lt;cons ,$px $&gt; [(multiset a)]
        {[$tgt (match tgt (list a)
                 {[&lt;join $hs &lt;cons ,px $ts&gt;&gt; {{@hs @ts}}]
                  [_ {}]})]}]
       [&lt;cons $ $&gt; [a (multiset a)]
        {[$tgt (match-all tgt (list a)
                 [&lt;join $hs &lt;cons $x $ts&gt;&gt; [x {@hs @ts}]])]}]
       [&lt;join ,$pxs $&gt; [(multiset a)]
        {[$tgt undefined]}]
       [$ [something]
        {[$tgt {tgt}]}]
       })))

(define $set
  (lambda [$a]
    (matcher
      {[&lt;nil&gt; []
        {[{} {[]}]
         [_ {}]}]
       [&lt;cons ,$px $&gt; [(set a)]
        {[$tgt (match tgt (list a)
                 {[&lt;join _ &lt;cons ,px _&gt;&gt; {tgt}]
                  [_ {}]})]}]
       [&lt;cons $ $&gt; [a (set a)]
        {[$tgt (match-all tgt (list a)
                 [&lt;join _ &lt;cons $x _&gt;&gt; [x tgt]])]}]
       [$ [something]
        {[$tgt {tgt}]}]
       })))

</code>
</pre>

</body>

<footer>
  <hr size=1 noshade>
  <table width=100% border=0 cellspacing=0>
    <tr>
      <td align=right>
        <i>
          <a href="http://egi.pira.jp">Egi Satoshi</a>
        </i>
    </tr>
  </table>
</footer>

</html>
